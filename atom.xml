<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wincer&#39;s Blog</title>
  <subtitle>言念君子，温其如玉。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.itswincer.com/"/>
  <updated>2017-12-31T07:31:29.483Z</updated>
  <id>https://blog.itswincer.com/</id>
  
  <author>
    <name>WincerChan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再见，2017</title>
    <link href="https://blog.itswincer.com/posts/5873b0c0/"/>
    <id>https://blog.itswincer.com/posts/5873b0c0/</id>
    <published>2017-12-29T02:46:06.000Z</published>
    <updated>2017-12-31T07:31:29.483Z</updated>
    
    <content type="html"><![CDATA[<p><div id="aplayer1" class="aplayer"></div><br>关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。</p>
<p>前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。<a id="more"></a><br>当初搭建博客的初衷其实很单纯:就是为了好玩，谁知从此就沉迷于此了。在之后的写博客的过程中甚至产生了一种当一个作家也还不错的想法（当然前提是我的文章还有人看😋），现在想想，与高中时期相比，我的想法是发生了一些转变（在高中时期的我是绝不可能产生这种想法的）。正如开始所说的，现在遇到点什么事就想写下来，在往年，我一直没有写年末总结的习惯。这种「创作欲」，类似作家：将自己内心的想法写成作品，实则是把自己的内心剖析给别人看。也渐渐有些明白卡尔·雅斯贝尔斯的那句「文学和科学相比，的确没什么用处，但文学最大的用处，也许就是它没有用处」的意思了。</p>
<hr>
<p>买了 kpw3 后，我很乐意培养自己的阅读习惯。大学时间其实还是比较宽松的，但我反而不能每天抽出一小时阅读时间。有时候看书没看两分钟，随便手机一个通知消息就能让我转移注意力——这也是我的缺点：当自己没有全神贯注的时候，很容易被其它的事情所吸引注意力（这也算我很迫切想改掉的一个坏习惯），也导致看了近两周才把《黑客与画家》这本书看完（书推过两天会补上）。</p>
<p>是太浮躁了，也太焦虑了，或许是因为到了大三，面临找工作的压力，这压力不仅体现在看书上，有时我就莫名想快些完成正在做的事情，后来多次发现快速完成的事情必然是敷衍的，而事后一旦想起这件「敷衍」的事情，会更加浮躁。其实这样并不好，道理古人都说给我们听了：「欲速则不达」，以后我会尽量放慢自己做事情的速度，投入自己的内心，问问自己真正想要的是什么。</p>
<hr>
<p>今年有过一段恋情，对我产生了一些影响，有好，也有坏，让我成长了许多，也意识到了自己的不足。是的，一段感情之后一定会让你成长的。我在这个过程中有开心、难过、有挂念一个人，甚至有些「病态」的想法——不论好坏，这些特殊的情感都是之前没有体会过的。</p>
<p>恋爱的时候，双方的关系一定需要去协商、磨合，这也会让你学会更好的与人沟通，同时你会发现有些问题如果脱离恋爱范围的话根本就不是问题。在一段恋情过后，我们获得的不仅仅是恋情，还有更好的、获得了成长的自己。你会更了解自己，也更了解你需要找一个什么样的人。</p>
<p>要有自己的生活，要坚持做自己。要学会去爱，但要先学会爱自己。</p>
<hr>
<p>接下来说说工作。</p>
<p>其实我很反感工作——即学校安排给你作为学生所必须学习的课程，所以这学期的课我基本没怎么去，因为去了我也不会听：我无法强迫自己去听那些完全没有兴趣的课程，那有点像是别人强迫要你去做的事情，我天生是一个「猫型人格」（即：你让我向左转，我会不由自主的向右转，同时心里还有一点歉疚），所以有些不由自主地抗拒。</p>
<p>在<a href="../11ab0263/">之前写的那篇文章</a>中就说到，我想更加追随自己内心的意愿去活着。具体到工作的说法就是：我想开始「不以找到工作为目的的学习」，学习自然指的是编程。</p>
<blockquote>
<p>编程这么有趣的事，竟然还有钱赚      ——by c++ 之父</p>
</blockquote>
<p>我喜欢编程，我愿意将自己的时间花费在上面做一些有趣的小程序，即使这在旁人看来对以后的工作没有什么帮助，我不想抱着太强的目的性、太多的功利心去学习，因为这样，会让学习变味。同时我也乐于看着指尖下的一串串字符到显示器上显示出成果，会有一种小小的满足感。</p>
<hr>
<p>最后，小小说一下对 2018 年的展望（这绝对不是 FLAG！）</p>
<ul>
<li>希望继续读书的习惯</li>
<li>希望做事情的时候更专注</li>
<li>希望能多吃水果、生活作息规律</li>
<li>希望学会使用 To-Do list（如果能有效治愈我的拖延症的话）</li>
</ul>
<script>new APlayer({element:document.getElementById("aplayer1"),narrow:false,autoplay:false,showlrc:3,mutex:true,theme:"#ad7a86",mode:"random",music:[{title:"u4",author:"Capo Productions",url:"https://p2.music.126.net/suBY_gYvEky44XIw3iosnA==/2946691176215291.mp3",pic:"https://p1.music.126.net/f2VOlJsKhocM3DPba4SLXA==/6625657069970131.jpg?param=130y130",lrc:"../../about/lrc/pure.lrc"}]});</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div id=&quot;aplayer1&quot; class=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;br&gt;关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。&lt;/p&gt;
&lt;p&gt;前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="随笔" scheme="https://blog.itswincer.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="2017" scheme="https://blog.itswincer.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>从 GnuPG 的使用谈谈密码学</title>
    <link href="https://blog.itswincer.com/posts/4aa5d46d/"/>
    <id>https://blog.itswincer.com/posts/4aa5d46d/</id>
    <published>2017-12-11T01:26:16.000Z</published>
    <updated>2017-12-27T04:01:51.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。</p>
<a id="more"></a>
<h2 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p>大概半年前，写过一个暴力破解加密压缩文件的程序，说白了就是跑字典，不断的试密码，这只能破解常用密码，一旦用户采用随机生成的密码就无从下手。我们平时所用到的压缩加密大多都是对称性加密，即我们用同一字符串对文件进行加密，又用同一字符串进行解密（此时为了保证安全，密码需越复杂越好）。</p>
<blockquote>
<p>明文 &lt;–&gt; 密钥 &lt;–&gt; 密文</p>
</blockquote>
<p>对称加密很方便也很快速，但是也带来了一个很大的缺点，由于加密和解密用的都是同一密钥，在传输的过程中，要求双方取得相同的密钥，这会大大降低加密的安全性（注意：这里所说的不安全不是说对称加密算法不安全，而是从密钥的获取程度来说的，即密钥知道的人越少越安全）。</p>
<p>在如今的互联网时代，通信双方分隔异地且素为谋面，则对称加密要求事先交换共同密钥的安全性也无法得到保障。</p>
<h2 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>那么为了解决对称加密的安全隐患，非对称加密诞生了。<br>与对称加密不同的是，非对称加密的加密和解密所需要的密钥是不同的，而且知道了其中一方，想推导出另一方（需要解决一个数学难题），在量子计算机时代来临之前，基本是不可能完成的。<br>因此公开其中一个密钥，并不会对密钥对的安全性有影响。<br>我们常说，公钥可以公开，私钥需要保密，但其实公钥和私钥在生成过程上，并无什么不同。并不是因为公钥公开后，解密出私钥困难，如果公开的是私钥，解密出公钥也同样困难。也就是说我们将一对密钥公开的那部分叫公钥，另一部分叫做私钥。并不是因为公钥，才能公开，私钥，就必须保密。</p>
<blockquote>
<p>明文 &lt;–&gt; 公钥 &lt;–&gt; 密文 &lt;–&gt; 私钥 &lt;–&gt; 明文</p>
</blockquote>
<p>前一段时间很火的勒索病毒就是采用的非对称加密中的 RSA-4096 加密算法。<br>想具体了解 RSA 加密原理的话，<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">点击这里</a>。<br>由于公钥加密在计算上相当复杂，导致其加密速度相对于对称加密来说慢。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>其中对称加密还有一个用处：数字签名。<br>对称加密的公钥和私钥在使用顺序上并没有什么要求，你可以用公钥加密，私钥解密，这就是非对称加密算法，同样可以用私钥加密，公钥解密，而这就成为数字签名。<br>由于私钥是发送者保存的，发送者用私钥加密后的信息，任何拥有该发送者的公钥的人都可以解密该信息。如果接收用发送者公开的公钥解开了，那么说明这个信息是确实是发送者发送的（没有被篡改，也不是伪造的）。公众也可以信赖这条信息确实来自与该用户，用户无法否认。</p>
<p>一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，并将签名附赠在消息一起发送。</p>
<p>总结一下二者的优点与缺点：</p>
<ul>
<li>对称密钥加密（使用最广泛的 AES）：加解密速度很快，强度也足够，但问题在于寻找一个安全通道让通信双方交换密钥很困难</li>
<li>公开密钥加密（使用最广泛的 RSA）：加解密速度很慢，但可以解决通信双方安全通道的问题</li>
</ul>
<p>故现在多将二者结合使用：需要加密的主体内容使用对称加密，对称加密的密钥使用非对称加密。</p>
<h2 id="GPG-教程"><a href="#GPG-教程" class="headerlink" title="GPG 教程"></a>GPG 教程</h2><p>下面说说如何使用 GPG 软件加密文件。</p>
<p>GPG 支持的算法有很多：</p>
<blockquote>
<p>公钥：RSA, ELG, DSA, ECDH, ECDSA, EDDSA</p>
<p>对称加密：IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256,</p>
<p>​     TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256</p>
<p>散列：SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</p>
<p>压缩：不压缩，ZIP，ZLIB，BZIP2</p>
</blockquote>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>使用对称加密很简单，只需要一行就可以：</p>
<pre><code class="bash">gpg --cipher-algo [对称加密算法名称] -c FILENAME
</code></pre>
<p>随后会让你输入两次密码，就会生成一个 FILENAME.gpg 的文件在同目录下。</p>
<p>解密：</p>
<pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg
</code></pre>
<p>更多参数请输入 <code>gpg -h</code> 自行查阅。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>（这里如果输入的是 <code>--gen-key</code> 的话，会省去一些步骤：自动设置密钥尺寸为 2048 位、有效期限为 2 年、注释留空）：</p>
<pre><code class="bash">gpg --full-generate-key
</code></pre>
<p>回车后，出现以下文字：</p>
<pre><code class="bash">gpg (GnuPG) 2.2.3; Copyright (C) 2017 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

请选择您要使用的密钥种类：
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (仅用于签名)
   (4) RSA (仅用于签名)
您的选择？
</code></pre>
<p>选择 1：</p>
<pre><code class="bash">RSA 密钥长度应在 1024 位与 4096 位之间。
您想要用多大的密钥尺寸？(2048)
</code></pre>
<p>选择 4096：</p>
<pre><code class="bash">请设定这把密钥的有效期限。
         0 = 密钥永不过期
      &lt;n&gt;  = 密钥在 n 天后过期
      &lt;n&gt;w = 密钥在 n 周后过期
      &lt;n&gt;m = 密钥在 n 月后过期
      &lt;n&gt;y = 密钥在 n 年后过期
密钥的有效期限是？(0)
</code></pre>
<p>如果想设置 5 年过期，输入 5y，我这里是自己私人用，选择 0，随后会让你确认以上信息正确与否，输入 y，系统会要求你提供一下个人信息：</p>
<pre><code class="bash">You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
    &quot;Heinrich Heine (Der Dichter) &lt;heinrichh#duesseldorf.de&gt;&quot;

真实姓名：
电子邮件地址：
注释：
</code></pre>
<p>注释这一栏可以留空。</p>
<p>随后：</p>
<pre><code class="bash">您选定了这个用户标识：
    “×××××× &lt;××@×××.com&gt;”

更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？
</code></pre>
<p>输入 o，会弹框提示设置一个密码，用于保护私钥。</p>
<p>与此同时，系统也会提示：</p>
<pre><code class="bash">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
</code></pre>
<p>几秒后，系统就会提示密钥已经生成。</p>
<h4 id="导出密钥"><a href="#导出密钥" class="headerlink" title="导出密钥"></a>导出密钥</h4><p>显示系统的私钥：</p>
<pre><code class="bash">gpg -K
</code></pre>
<p>显示系统的公钥：</p>
<pre><code class="bash">gpg -k
</code></pre>
<p>删除密钥：</p>
<pre><code class="bash">gpg --delete-keys [uid]
gpg --delete-secret-keys [uid]
</code></pre>
<p>其中 uid 可以使用邮箱代替，下同。</p>
<p>导出公钥：</p>
<pre><code class="bash">gpg -o public.key --export [uid]
</code></pre>
<p>导出私钥：</p>
<pre><code class="bash">gpg -o private.key --export-secret-keys
</code></pre>
<p>这样导出的 key 文件是二进制，不可读，加上 –armor 参数可以保存为 ASCII 码形式。</p>
<p>导入密钥：</p>
<pre><code class="bash">gpg --import [key 文件]
</code></pre>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><pre><code class="bash">gpg -r [uid] -o FILENAME.gpg -e FILENAME
</code></pre>
<p>-r 指定用户的公钥，如自己使用改为自己邮箱即可，-o 指定加密后输出文件名称。</p>
<h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg
</code></pre>
<p>会让你输入密码，即用于保护私钥的密码。</p>
<p>参考：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="external">公开密钥加密</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="external">GPG 入门教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="GPG" scheme="https://blog.itswincer.com/tags/GPG/"/>
    
      <category term="密码学" scheme="https://blog.itswincer.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="安全" scheme="https://blog.itswincer.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化（一）——使用 localStorage</title>
    <link href="https://blog.itswincer.com/posts/a9d193c6/"/>
    <id>https://blog.itswincer.com/posts/a9d193c6/</id>
    <published>2017-11-30T07:09:34.000Z</published>
    <updated>2017-12-26T04:02:07.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="localStorage-的意义"><a href="#localStorage-的意义" class="headerlink" title="localStorage 的意义"></a>localStorage 的意义</h2><p>为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经<a href="https://itswincer.com/posts/a0df572f/">开启了 Server Worker 技术</a>，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。</p>
<a id="more"></a>
<p>而且对于 Server Worker，它并不能减少你的 HTTP 连接数量，只是拦截你的请求，减少 Stalled、Request sent 和 TTFB 的时间，见下图：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/11/30/5a1fb5e57fcf3.png" alt="左边从 SW 加载，右边正常加载" title="左边从 SW 加载，右边正常加载"></p>
<p>针对以上两个问题，本博客采用另一种 HTML5 新技术 —— local Storage。</p>
<h2 id="localStorage-简介"><a href="#localStorage-简介" class="headerlink" title="localStorage 简介"></a>localStorage 简介</h2><p>localStorage 是在 HTML5 中新引进的一项存储技术，（如果不被清除）存储没有时间限制，但是有大小限制，一般对于每个域名是 5MB，对于存储一些纯字符串脚本，足够了。且目前所有主流浏览器均支持此项技术。</p>
<p>但是需要注意，SW 是可以将所有的 HTTP 请求全部拦截，无论服务器的 Response Headers 中的 Content-Type 是什么类型都可以拦截从本地加载。而 localStorage 仅能存储静态资源（JS/CSS）。</p>
<p>而存储在 localStorage 的中的静态资源所带来的优点就在于再次加载时不需要发起 HTTP 请求（Queueing、Stalled、Request sent、TTFB、Content Download 这些都不需要），这可以大大改善不支持 SW 技术的浏览器在访问我网站时的浏览体验。</p>
<h2 id="本博客的实践"><a href="#本博客的实践" class="headerlink" title="本博客的实践"></a>本博客的实践</h2><p>本博客采用的是 <a href="https://github.com/addyosmani/basket.js/" target="_blank" rel="external">basket.js</a> 方案，将 js 和 css 存储在 localStorage 中，利用 localStorage 的特性，减少 HTTP 连接的次数，以达到改善页面加载体验的目的。</p>
<p>为了避免每次刷新页面 main.css 加载先后页面出现抖动的问题，默认不将 main.css 放入 localStorage 中存储。</p>
<p>另一个问题是 NexT 在设计之初就很依赖于 js（会加载大量的 js 文件），而这些 js 文件的加载顺序是有要求的，jquery 必须优先被加载，否则就会出现奇怪的 bug，好在 basket.js 提供了控制加载先后顺序的方案。</p>
<h2 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h2><p>在<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="external">这篇知乎回答</a>中，很详细的列出了 localStorage 的优点和缺点。</p>
<p>其中最危险的是网站出现 xss 漏洞，就会被人利用将恶意代码注入到 localStorage 中，导致即便修复了 xss 漏洞存储的代码依然是被篡改的。</p>
<p>好在 basket.js 可以提供将 localStorage 中的代码重新从网络加载的问题。具体见<a href="https://addyosmani.com/basket.js/" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;localStorage-的意义&quot;&gt;&lt;a href=&quot;#localStorage-的意义&quot; class=&quot;headerlink&quot; title=&quot;localStorage 的意义&quot;&gt;&lt;/a&gt;localStorage 的意义&lt;/h2&gt;&lt;p&gt;为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经&lt;a href=&quot;https://itswincer.com/posts/a0df572f/&quot;&gt;开启了 Server Worker 技术&lt;/a&gt;，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="优化" scheme="https://blog.itswincer.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="localStorage" scheme="https://blog.itswincer.com/tags/localStorage/"/>
    
      <category term="Web" scheme="https://blog.itswincer.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>这盛世可如你所愿？</title>
    <link href="https://blog.itswincer.com/posts/d67271d8/"/>
    <id>https://blog.itswincer.com/posts/d67271d8/</id>
    <published>2017-11-24T06:10:04.000Z</published>
    <updated>2017-12-29T03:38:39.344Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>
function doDecrypt(pwd, onError) {
	console.log("in doDecrypt");
	var txt = document.getElementById("enc_content").innerHTML;
	var plantext;
	try {
	  	var bytes = CryptoJS.AES.decrypt(txt, pwd);
		plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {onError(err);}
		return;
	}
	document.getElementById("enc_content").innerHTML = plaintext;
	document.getElementById("enc_content").style.display = "block";
   document.getElementById("enc_passwd").style.display = "none";
}
</script>
<div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <div class="encrypt"> <script> var onError = function(error) { $("#enc_error")[0].innerHTML = "密码错误！"; }; function decrypt() { var passwd = $("#enc_passwd input")[0].value; console.log(passwd); doDecrypt(passwd, onError); } function EnterPress(e){ var e = window.event || e; if (e.keyCode == 13){ decrypt(); } } </script> <input type="text" onkeydown="EnterPress" onkeypress="EnterPress(event)" style="/* border-radius: 10px; */border-style: groove;/* border: 0px; */border-bottom: 2px solid #0097a7; /* 下划线效果 */border-top:0px;border-left:0px;border-right:0px;height: 30px;width: 61.8%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;background: #61616;padding-left: 5px" placeholder="输入密码后请按回车"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "> </div> </div> </div>]]></content>
    
    <summary type="html">
    
      我曾听说住在罗生门的恶鬼，因为害怕人性的残忍而逃走。——《罗生门》 ——谨以此文献给十九大之后的「太平盛世」。
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="政治" scheme="https://blog.itswincer.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="国情" scheme="https://blog.itswincer.com/tags/%E5%9B%BD%E6%83%85/"/>
    
      <category term="严肃向" scheme="https://blog.itswincer.com/tags/%E4%B8%A5%E8%82%83%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Poker 机械键盘开箱与简评</title>
    <link href="https://blog.itswincer.com/posts/72474942/"/>
    <id>https://blog.itswincer.com/posts/72474942/</id>
    <published>2017-11-02T05:56:40.000Z</published>
    <updated>2017-12-26T04:02:07.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一入外设深似海，从此钱财是路人。</p>
</blockquote>
<h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。</p>
<p>后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：</p>
<p>年轻人千万别碰哪些东西？</p>
<ol>
<li>毒品</li>
<li>游戏显卡</li>
<li>Hi-Fi 耳机</li>
<li>固态硬盘</li>
<li>机械键盘</li>
<li>Steam Origin Uplay</li>
<li>. . .</li>
</ol>
<a id="more"></a>
<p>当时大一，看到这个段子就笑了一笑，面对从一百多到一千多价位不等的机械键盘，还是比较理智的，听人说凯华轴的手感也是最接近 Cherry 轴的，于是就买了贼鸥 87，用了快两年，这期间：鼠标换了两个，耳机也买了两个，键盘却一直在用这一个，最近有几个键不灵了，正好趁着双十一，想着干脆换一把新的。心中对 Poker 那独特的键位种草已久，可惜京东没有 Poker II 的红轴版本，于是便入手了一代。</p>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>不愧是「二手东」，这饱经沧桑的包装盒：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b64c7fd6.jpg" alt="Poker 外包装" title="Poker 外包装"></p>
<p>关于包装盒，去拿快递的时候还发生了一个小插曲：当时京东的人问我手机尾号，我告诉了她，然后又问我是什么东西，我说是一把键盘，然后他就去找，找了半天，没找到，然后就问另一个人，说：“尾号是 6 的快件都在这里了吧，怎么没有键盘啊？”，然后转头问我：“键盘应该是挺大的吧？”，我说：“不，不大，挺短的”，然后她又去找小一点的包裹，结果一找就找到了。</p>
<p>回到寝室，迫不及待的拆开了包装：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214de043960.jpeg" alt="Poker 包装内容" title="Poker 包装内容"></p>
<p>这便是全家福了，包含：键盘本体、USB 连接线、RGB 的大键键帽、说明书、拔键器。</p>
<p>其中连接线带有屏蔽磁环，做工也算精良。</p>
<h2 id="60"><a href="#60" class="headerlink" title="60%"></a>60%</h2><p>Poker 这一系列，最大的特点应当就是 60% 尺寸的设计了，准确来说是 61 键。相对于普通 87 键的键盘，尺寸更加玲珑小巧，省去了方向键和功能键，改为用 <code>FN</code> 的组合键来实现相应功能。方向键是用 <code>Fn</code> + WASD 来实现，不过，对于用 Spacemacs 的我来说，没啥影响，哈哈。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214ddff3afa.jpeg" alt="键盘本体" title="键盘本体"></p>
<p>真正拆开的时候才发现 60% 尺寸带来的冲击有多么大。</p>
<p>说到组合键，<code>Fn</code> 与组合键的功能在侧刻上都已标注：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b6385bab.jpeg" alt="Poker 的侧刻" title="Poker 的侧刻"></p>
<p><code>Fn</code> 与数字键组合就是 F1~F12。<code>Fn</code> + N、M、&lt; 分别是音量 -、+、静音等。</p>
<h2 id="轴和键帽"><a href="#轴和键帽" class="headerlink" title="轴和键帽"></a>轴和键帽</h2><p>说道机械键盘的核心，应当就是轴体和键帽了。</p>
<h3 id="轴体"><a href="#轴体" class="headerlink" title="轴体"></a>轴体</h3><p>轴体方面，采用的是 Cherry 原厂轴体，大键也是卫星轴设计。手感嘛，自然是没话说了。我这里购买的是红轴的版本，毕竟用了两年，还是红轴最为顺手。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b63d5896.jpeg" alt="Cherry 红轴" title="Cherry 红轴"></p>
<h3 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a>键帽</h3><p>键帽采用的是 PBT 材质，对于 ABS 来说，PBT 的好处就是绝不会打油。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b62f0af5.jpeg" alt="键盘 + 手托" title="键盘 + 手托"></p>
<p>而且这款 PBT 键帽比我之前在网上购入的 PBT 键帽手感要更胜一筹，对着光看起来还闪着微弱的光，挺有意思。</p>
<p>在上图键 F、G、H 的侧面，可以看到有三个数字，分别是 15ms、0.1s、0.5s，这是允许用户调整按下键帽时的响应速度。这一点也是比较新奇。</p>
<h2 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b63d57a5.jpeg" alt="正面&#39;遗照&#39;" title="正面&#39;遗照&#39;"></p>
<p>相对与小巧玲珑的正面来说，背部就没有那么精致了：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://i.loli.net/2017/12/01/5a214b63a7325.jpeg" alt="键盘背部" title="键盘背部"></p>
<p>四周是四个黑色的防滑垫，没有撑脚，可能是为了缩减体积来作出的取舍（当然键盘也设计成了前高后低的人体工学形状），防滑垫对我来说用处不大，因为我是把键盘放在鼠标垫上使用的。</p>
<p>中间那块金属铭牌上刻着一句英文：「<strong>The keyboard to cheer you up</strong>」（用这把键盘让你高兴起来！）</p>
<p>可能会注意到在底部的右侧有四个很小的指拨开关，作用分别是：</p>
<ul>
<li>开关 1：CAP = 左 WIN；CAP 灯 = 左 WIN 灯</li>
<li>开关 2：右 CTRL = `~</li>
<li>开关 3：左 WIN = 左 FN</li>
<li>开关 4：写保护键盘</li>
</ul>
<h2 id="编程功能"><a href="#编程功能" class="headerlink" title="编程功能"></a>编程功能</h2><p>这一功能也算是 Poker 的特色了，目前还不是很了解，先放一放，过几天等了解了再补上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>换上附赠的 RGB 键帽后，白色素雅的 Poker 顿时骚了起来，哈哈。</p>
<p>由于是 mini 键盘，我的手托也就不那么合适（长了一截，无关紧要）。</p>
<p>一把 60% 键盘，精简了多余的按键和尺寸，为便携带来了许多好处（要是再赠送一个保护套就更完美了）。做工上乘，手感尚佳，不过大键的手感稍肉，Cherry 原厂轴加上 PBT 键帽，算的是 IKBC 的良心之作，值得入手。（怎么感觉写成了软文 23333</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一入外设深似海，从此钱财是路人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初识&quot;&gt;&lt;/a&gt;初识&lt;/h2&gt;&lt;p&gt;第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。&lt;/p&gt;
&lt;p&gt;后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：&lt;/p&gt;
&lt;p&gt;年轻人千万别碰哪些东西？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;毒品&lt;/li&gt;
&lt;li&gt;游戏显卡&lt;/li&gt;
&lt;li&gt;Hi-Fi 耳机&lt;/li&gt;
&lt;li&gt;固态硬盘&lt;/li&gt;
&lt;li&gt;机械键盘&lt;/li&gt;
&lt;li&gt;Steam Origin Uplay&lt;/li&gt;
&lt;li&gt;. . .&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="开箱" scheme="https://blog.itswincer.com/tags/%E5%BC%80%E7%AE%B1/"/>
    
      <category term="键盘" scheme="https://blog.itswincer.com/tags/%E9%94%AE%E7%9B%98/"/>
    
      <category term="评测" scheme="https://blog.itswincer.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>构建一言 API 踩坑记录</title>
    <link href="https://blog.itswincer.com/posts/f6e1eb2a/"/>
    <id>https://blog.itswincer.com/posts/f6e1eb2a/</id>
    <published>2017-10-30T02:44:41.000Z</published>
    <updated>2017-12-26T04:02:07.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。</p>
<p>最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。<br><a id="more"></a></p>
<h2 id="获取一言"><a href="#获取一言" class="headerlink" title="获取一言"></a>获取一言</h2><p>最开始准备构建的时候，就遇到了一个问题：一言的数据库去哪里找。我翻便了 Google，基本都是提供 API 的，并不会将完整的数据库给你。这想想也正常，都把数据库给你了，那谁还用你的 API 呢。</p>
<p>我就花了一下午，写了一个爬虫，对准了几个提供 API 的网站，开始爬去数据。但是由于 API 产生的数据是随机的，难免会有重复。所以爬取之后又要查重，着实花费了我不少时间。</p>
<p>整个过程大概花了一天多，做成了一个 JSON 格式的文件，然后用 JS 导入成为数组，再随机访问数组的某一项，这便是最初“本地版”的「一言」了。</p>
<h2 id="转化数据库"><a href="#转化数据库" class="headerlink" title="转化数据库"></a>转化数据库</h2><p>先前已经说过，一旦数据多了起来。那么数组的访问和加载都是问题，而访问慢的问题可以用数据库来解决。而这学期正好在学数据库这门课，于是便花了点时间将 JSON 格式的数据转化成 sqlite 数据库。JSON 格式的数据有需要的只有 3 项，分别是 ID（用以标识每个 Hitokoto）、HITOKOTO（每个 Hitokoto 的内容）、SOURCE（每个 Hitokoto 的出处）。知道了这些，转化的代码就呼之欲出了：</p>
<pre><code class="python">import json
import sqlite3

JSON_FILE = &quot;hitodb.json&quot;
DB_FILE = &quot;HITODB.db&quot;
conn = sqlite3.connect(DB_FILE)

with open(JSON_FILE, &#39;r&#39;) as load_f:
    data = json.load(load_f)
    for line in data:
        print(int(line[&quot;id&quot;]), line[&quot;hitokoto&quot;], line[&quot;from&quot;])
        conn.execute(
            &#39;INSERT INTO HITOKOTO (ID, HITO, SOURCE) VALUES ({a}, \&#39;{b}\&#39;, \&#39;{c}\&#39;)&#39;.
            format(a=line[&#39;id&#39;], b=line[&#39;hitokoto&#39;], c=line[&#39;from&#39;]))
        conn.commit()

print(&#39;Successfully&#39;)

conn.close()
</code></pre>
<p>截至至本文发布，该「一言」数据库共收录了 880 条记录，以后我还会陆续添加。</p>
<h2 id="生成-API"><a href="#生成-API" class="headerlink" title="生成 API"></a>生成 API</h2><p>有了数据库，自然要构建一个 API，这里选用的是 Flask 框架提供的接口。</p>
<p>首先你需要安装 Flask，而 Python 是自带 sqlite3 模块的。直接上代码：</p>
<pre><code class="python">import sqlite3

from flask import Flask, jsonify

app = Flask(__name__)


@app.route(&#39;/&#39;)
def index():
    return &#39;Hello World!&#39;


@app.route(&#39;/api/&#39;)
def get_hito():
    conn = sqlite3.connect(&#39;HITODB.db&#39;)
    hito = conn.execute(
        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()
    hitokoto = &quot;{} ——「{}」&quot;.format(hito[1], hito[2])
    return &#39;function hitokoto() { &#39; + &#39;document.write(\&#39;{}\&#39;);&#39;.format(
        hitokoto) + &#39;}&#39;


@app.route(&#39;/api/json/&#39;)
def get_json():
    conn = sqlite3.connect(&#39;HITODB.db&#39;)
    hito = conn.execute(
        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()
    hitokoto = {}
    hitokoto[&#39;id&#39;] = hito[0]
    hitokoto[&#39;hito&#39;] = hito[1]
    hitokoto[&#39;source&#39;] = hito[2]
    return jsonify(hitokoto)


if __name__ == &#39;__main__&#39;:
    app.run(host=&#39;0.0.0.0&#39;, debug=True)
</code></pre>
<p>保存为 <code>run.py</code>。然后运行，打开 <code>http://0.0.0.0/api/</code> 如果没有意外的话，应当是成功了。接下来就是部署了。</p>
<h2 id="部署至-Heroku"><a href="#部署至-Heroku" class="headerlink" title="部署至 Heroku"></a>部署至 Heroku</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>一开始担心是没有主机，后来才知道有「<a href="https://dashboard.heroku.com/" target="_blank" rel="external">Heroku</a>」这个造福大众的云平台服务。</p>
<p>首先你需要安装 <a href="https://toolbelt.heroku.com/" target="_blank" rel="external">Heroku 客户端工具</a>，安装完成后，输入以下命令来验证安装是否成功：</p>
<pre><code class="bash">$ heroku --version
</code></pre>
<p>安装成功后，在本地命令行登录 Heroku：</p>
<pre><code class="bash">$ heroku login
</code></pre>
<p>然后输入你的帐号和密码即可</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>可以在<a href="https://dashboard.heroku.com/apps" target="_blank" rel="external">网页端创建</a>，也可以在命令行创建：</p>
<pre><code class="bash">$ heroku create wincer-hito
</code></pre>
<p>这里或许会提示你名字已经被使用了，换一个就好。接下来要初始化本地和远程代码库。</p>
<pre><code class="bash">$ mkdir hitokoto                    # 创建本地代码仓库
$ cd hitokoto                        # 切换至本地仓库目录
$ git init                            # 初始化本地仓库
$ heroku git:remote -a wincer-hito    # 链接到远程仓库
</code></pre>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>除了代码和数据库外，两个必要的文件：<code>requirements.txt</code> 部署应用时，远程环境会自动安装 <code>requirements.txt</code> 文件中列出的依赖。我们 <code>requirements.txt</code> 文件内容如下：</p>
<pre><code class="python">Flask==0.12.2
gunicorn==19.4.5
</code></pre>
<p>接下来，我们如何告诉服务器如何运行这个文件呢？就要通过 <code>Procfile</code> 文件了。</p>
<pre><code>web: gunicorn run:app
</code></pre><p>以上就是 <code>Procfile</code> 的内容。</p>
<p>另根据习惯，可自行添加对该项目的描述。</p>
<p>接下来就是激动人心的提交了：</p>
<pre><code class="bash">$ git add .
$ git commit -m &quot;Init commit&quot;
$ git push heroku master
</code></pre>
<p>打开 <a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="external">https://wincer-hito.herokuapp.com/api/</a> 看看效果吧！</p>
<h3 id="升级应用"><a href="#升级应用" class="headerlink" title="升级应用"></a>升级应用</h3><p>升级程序的时候，在所有的改动提交后，建议按照如下步骤升级：</p>
<pre><code class="bash">$ heroku maintenance:on
$ git push heroku master
$ heroku run python run.py deploy        # run.py改成自己的文件名
$ heroku restart
$ heroku maintenance:off
</code></pre>
<h2 id="使用-API"><a href="#使用-API" class="headerlink" title="使用 API"></a>使用 API</h2><p>数据获取：</p>
<ul>
<li>请求地址：<a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="external">https://wincer-hito.herokuapp.com/api/</a></li>
<li>请求方式：GET</li>
<li>返回函数名 hitokoto 的 js 脚本，本质为 document.write 函数的脚本</li>
<li>如果需要 json 格式的数据：<a href="https://wincer-hito.herokuapp.com/api/json/" target="_blank" rel="external">https://wincer-hito.herokuapp.com/api/json/</a></li>
<li>如果仅需要 hitokoto 主体：<a href="https://wincer-hito.herokuapp.com/api/main/" target="_blank" rel="external">https://wincer-hito.herokuapp.com/api/main/</a></li>
</ul>
<p>在你想使用「一言」的地方插入以下代码：</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://wincer-hito.herokuapp.com/api/&quot;&gt;&lt;/script&gt;
&lt;script&gt;hitokoto();&lt;/script&gt;
</code></pre>
<p>演示效果看侧栏。</p>
<p>注：由于是 Heroku 的主机是在美国，所以该 API 延迟可能会有一点高。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。&lt;/p&gt;
&lt;p&gt;最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。&lt;br&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Hitokoto" scheme="https://blog.itswincer.com/tags/Hitokoto/"/>
    
      <category term="Flask" scheme="https://blog.itswincer.com/tags/Flask/"/>
    
      <category term="API" scheme="https://blog.itswincer.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Linux 与 Windows 10 用 GRUB 引导教程</title>
    <link href="https://blog.itswincer.com/posts/ad42f575/"/>
    <id>https://blog.itswincer.com/posts/ad42f575/</id>
    <published>2017-10-17T03:35:19.000Z</published>
    <updated>2017-12-31T01:56:39.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。</p>
<h2 id="EFI-分区"><a href="#EFI-分区" class="headerlink" title="EFI 分区"></a>EFI 分区</h2><p>在教程正式开始之前，先花一点时间说明 EFI 分区的组成和作用。<br>首先，在你装了 Windows 之后，Windows 在装机过程中会将硬盘划分出一个约 100m 大小的分区，称为 EFI 分区这个分区就是起引导作用的。在资源管理器中是看不到的这个分区的，可以在磁盘管理中看到，管理则需要借助 <a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DG 工具</a>。便于说明，在装好了 Linux 之后，我将 EFI 挂载至 boot 分区截图：<br><a id="more"></a><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fkl3a5pwv6j20ng0hwwfn.jpg" alt=""><br>可以看到，该分区包含 3 个文件夹（如果你没有装 Linux 的话，就只有两个），分别是 Boot、Microsoft 和 Manjaro，其中 Boot 文件夹就是 UEFI 引导所必需的文件。<br>我们继续打开 <code>Microsoft/Boot</code> 文件夹：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fkl3b006w1j20ng0hwdhj.jpg" alt=""></p>
<p>这些文件就是启动 Windows 10 所必需的，包含了语言包、字体等，BCD 包含了 Windows 引导开始以后的信息。其中，<strong>bootmgfw.efi 是 Windows 默认引导文件</strong>。</p>
<ol>
<li>EFI/Boot/bootx64.efi</li>
<li>EFI/Microsoft/Boot/bootmgfw.efi</li>
</ol>
<p>以上是采用 UEFI 启动 Windows 10 的文件结构，也就是说，当你按下开机按钮的时候，首先 UEFI 找到 EFI 分区的 Boot 文件夹，然后加载 <code>bootx64.efi</code> 文件，读取文件信息，找到 <code>EFI/Microsoft/Boot/bootmgfw.efi</code>，按照 <code>bootmgfw.efi</code> 的要求，加载所需的启动信息，启动 Windows 10。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式装系统之前，我们还需要做一些准备工作：</p>
<h3 id="关闭-Windows-的快速启动"><a href="#关闭-Windows-的快速启动" class="headerlink" title="关闭 Windows 的快速启动"></a>关闭 Windows 的快速启动</h3><p>这个功能的作用是在于关机的时候不完全断电，类似将系统处于「休眠」状态，这样可以让开机更加迅速。但这也就导致了只能使用 Windows 系统。</p>
<h3 id="关闭-BIOS-的-Secure-Boot-的功能"><a href="#关闭-BIOS-的-Secure-Boot-的功能" class="headerlink" title="关闭 BIOS 的 Secure Boot 的功能"></a>关闭 BIOS 的 Secure Boot 的功能</h3><p>在默认情况下，UEFI 固件只会加载那些被签名的引导程序。在缺少 Secure Boot 功能的传统 PC 机上，恶意的后门程序可以加载自身，进而摇身一变伪装成一个引导程序。这样的话，BIOS 就会在启动的时候加载后门程序，这样它就可以躲过操作系统，把自己隐藏得很深。<br>但是不得不说，这对我们安装 Linux 造成了很大的困扰，也是直接导致我们重启到 Windows 10 后进不去 Linux 的原因。<br>首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。</p>
<h2 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h2><p>所有的准备都已经完成，这时就可以准备刻录 U 盘了，不推荐 UltraISO，经亲测，软碟通仅刻录 Ubuntu 能成功，其它绝大多数发行版都会失败。推荐「<a href="https://rufus.akeo.ie/" target="_blank" rel="external">Rufus</a>」和「<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="external">USBWriter</a>」，这两个软件都可以。<br>刻录完成后，重启按 <code>f12</code>，选择从 USB 设备启动，对于绝大多数发行版来说一路回车就行了，只需要注意一点：<strong>在选择挂载 boot 位置的时候，一定要挂载在 efi 分区</strong>，别的都不行。<br>重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。</p>
<h2 id="替换引导文件"><a href="#替换引导文件" class="headerlink" title="替换引导文件"></a>替换引导文件</h2><p>先用 DG 打开 EFI 分区，你会看到多了一个文件夹，名称取决于你安装的是哪一个发行版。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。步骤：</p>
<ol>
<li>进入管理员命令行。方法：win + x，再按 a</li>
<li>输入 <code>bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</code>。提示操作成功的话，就完成了。</li>
</ol>
<p>至此，如果你安装的是除 Arch 之外绝大多数发行版，那么接下来就和你没有啥关系了，你已经成功了，好好享受吧！</p>
<p>开机之后会发现进入 GRUB 的引导了，通常会包含至少三个选项（以 Manjaro 举例）：Manjaro、Manjaro 高级选项和 Windows Manager。这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题。</p>
<h2 id="修复-Windows-引导"><a href="#修复-Windows-引导" class="headerlink" title="修复 Windows 引导"></a>修复 Windows 引导</h2><p>这一点是我安装 Arch Llinux 的时候发现的，Arch Linux 安装过程是手动安装的，在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区（当然可能不是所有人都会遇到），所以在 GRUB 界面可能会看不到 Windows Manager 选项，导致进不去 Windows 10，这里就需要手动编辑 GRUB 信息，我们打开 <code>/boot/grub/grub.cfg</code> 文件，发现里面确实没有 Windows 10 的启动信息，在后面加上：</p>
<pre><code class="bash">menuentry &quot;Microsoft Windows 10&quot; {
  insmod part_get
  insmod fat
  insmod search_fs_uuid
  insmod chain
  search --fs-uuid --set=root $hints_string $fs_uuid
  chainloader /EFI/Microsoft/Boot/bootmgfw.efi
}
</code></pre>
<p><strong>注意</strong>：</p>
<p>这里的 <code>$hints_string</code>，代表的是终端执行命令：</p>
<pre><code class="bash">sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>后的输出；</p>
<p>而 <code>$fs_uuid</code> 代表的是：</p>
<pre><code class="bash">sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi
</code></pre>
<p>的输出。</p>
<p>然后保存。在终端执行命令：<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>，就 OK 了。</p>
<p>到此，Arch Linux 和 Windows 10 双系统也配置完毕了。</p>
<h2 id="附加问题"><a href="#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><p>在使用这一年多的时间，遇到了以下的几个问题：</p>
<ol>
<li>在 Windows 10 进行了一个大更新后，会发现 GRUB 引导界面没有了，还是直接进入了 Windows 10，这时只需要按照 <code>替换引导文件</code> 的方法重新输入一遍命令就行。</li>
<li>使用 Linux 某个发行版一段时间之后，难免会想尝试一下另一个发行版。这时请务必将之前的发型版的引导文件删除，否则可能会出现无论怎么设置都无法进入 GRUB 的情况。例如：我之前用的是 Ubuntu，我现在换成了 Manjaro，我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹。</li>
<li>在我使用 Manjaro 更新了一次 Linux 的内核后，进不去 Windows 10 了，这个时候千万不要直接修复 Windows 10 引导，这会格式化 EFI 分区，只需要按上面 <a href="https://itswincer.com/posts/ad42f575/#%E4%BF%AE%E5%A4%8D-Windows-%E5%BC%95%E5%AF%BC">修复 Windows 引导</a> 的方法编辑一下 GRUB 就可以了。</li>
</ol>
<p>最后：祝使用愉快。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;EFI-分区&quot;&gt;&lt;a href=&quot;#EFI-分区&quot; class=&quot;headerlink&quot; title=&quot;EFI 分区&quot;&gt;&lt;/a&gt;EFI 分区&lt;/h2&gt;&lt;p&gt;在教程正式开始之前，先花一点时间说明 EFI 分区的组成和作用。&lt;br&gt;首先，在你装了 Windows 之后，Windows 在装机过程中会将硬盘划分出一个约 100m 大小的分区，称为 EFI 分区这个分区就是起引导作用的。在资源管理器中是看不到的这个分区的，可以在磁盘管理中看到，管理则需要借助 &lt;a href=&quot;http://www.diskgenius.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DG 工具&lt;/a&gt;。便于说明，在装好了 Linux 之后，我将 EFI 挂载至 boot 分区截图：&lt;br&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Linux" scheme="https://blog.itswincer.com/tags/Linux/"/>
    
      <category term="Windows" scheme="https://blog.itswincer.com/tags/Windows/"/>
    
      <category term="双系统" scheme="https://blog.itswincer.com/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Kindle Papwerwhite 开箱 &amp; 简评</title>
    <link href="https://blog.itswincer.com/posts/6619f85a/"/>
    <id>https://blog.itswincer.com/posts/6619f85a/</id>
    <published>2017-10-05T04:33:46.000Z</published>
    <updated>2017-12-26T04:02:07.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是冲不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的“老古董”了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。</p>
<a id="more"></a>
<p>其实我最近是比较少看书了，现在看的这本《雪中悍刀行》看了半年多才看了一半，上本《将夜》看了一年，一方面是看的书越多，品味自然也高了起来，现在写的好的小说是越来越少，之前一直很喜欢的几个作者要么更新是越来越慢（比方说：烽火戏诸侯，愤怒的香蕉）、要么是书的质量不如之前（比方说：烟雨江南、猫腻），有点担心自己看完了就书荒了。</p>
<p>我买 Kindle 不是为了亚马逊庞大的图书资源（我看书只自己在网上找），而是因为那块 E-ink 屏幕，而且因为 Kindle 那可怜兮兮的娱乐功能，用 Kindle 时可以更专注于看书。而国庆前几天一直忙于跑亲戚，所以直到今天才有空闲时间开箱。</p>
<h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>这就是全部的配件（裸机 + 数据线）了：右边是卖家附赠的</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk79ezf45nj243k2aokjl.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>阅读灯</td>
<td style="text-align:left">4 颗</td>
</tr>
<tr>
<td>解析度</td>
<td style="text-align:left">300 ppi</td>
</tr>
<tr>
<td>重量</td>
<td style="text-align:left">205 g</td>
</tr>
<tr>
<td>尺寸</td>
<td style="text-align:left">169 × 117 × 9.1 mm</td>
</tr>
<tr>
<td>屏幕</td>
<td style="text-align:left">6 吋</td>
</tr>
<tr>
<td>容量</td>
<td style="text-align:left">4 GB</td>
</tr>
<tr>
<td>连接</td>
<td style="text-align:left">Wi-Fi</td>
</tr>
<tr>
<td>运存</td>
<td style="text-align:left">512 mb</td>
</tr>
</tbody>
</table>
<h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>开完箱经过简单的设置之后，迫不及待的从电脑传了几本书（谁都阻止不了我想读书的心情！）。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9im0k3boj20ts148wkb.jpg" alt=""></p>
<p>吐槽一下，这里是无法像多看一样做成文件浏览的形式，也就是说，即使你把一些书放进新建的文件夹里（便于归类管理），它也是直接在首页显示。</p>
<p>这就是阅读界面的选项了，选项少的可怜，而且页边距太大！我这已经设置页边距最小了。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9iomwwanj20ts148myo.jpg" alt=""></p>
<p>得益于 Kindle 这块 4:3 的屏幕，看漫画可以说是比手机更具优势。清晰度是够了，要是屏幕再大一些就好了：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9ini80jaj20ts148abd.jpg" alt=""></p>
<p>如果想要购买正版书，就在上方的搜索按钮输入书名：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9inv9codj20ts148jue.jpg" alt=""></p>
<p>设置界面确实寒酸，不过想想要的只是纯粹的阅读体验，也就释然了：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9iod1ccgj20ts148aan.jpg" alt=""></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fk9imyqm95j20ts148q3j.jpg" alt=""></p>
<p>使用了<del>半个多小时</del>两天多了，简单总结一下感受：</p>
<ol>
<li>300 ppi 看起书来真的是太 ™ 爽了</li>
<li>在翻页的速度上，相比前几代快了不少，当然和手机还是没法比</li>
<li>阅读灯对我来说没啥用，我晚上看书也会开台灯</li>
<li>页边距实在太大，我都已经调整成了最小边距了，可还是留白太多</li>
<li>系统功能相比多看来说还是少了一些，比如无法设置全刷页数</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>买 kpw3 之前其实还有一个顾虑，就是刷不了「多看」，我的电子书资源多是 「epub」格式的，而 Kindle 的原生系统是<strong>不支持</strong>「epub」格式的（我一直搞不懂为什么亚马逊不支持）现在我每一本书都要转成 「mobi」 才能在 Kindle 上看。</p>
<p>还有就是实体翻页键了，等我经济独立之后，一定要买 Oasis！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是冲不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的“老古董”了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="开箱" scheme="https://blog.itswincer.com/tags/%E5%BC%80%E7%AE%B1/"/>
    
      <category term="Kindle" scheme="https://blog.itswincer.com/tags/Kindle/"/>
    
      <category term="简评" scheme="https://blog.itswincer.com/tags/%E7%AE%80%E8%AF%84/"/>
    
      <category term="电子书" scheme="https://blog.itswincer.com/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Spacemacs 生存指北</title>
    <link href="https://blog.itswincer.com/posts/2aa541e6/"/>
    <id>https://blog.itswincer.com/posts/2aa541e6/</id>
    <published>2017-09-26T05:01:33.000Z</published>
    <updated>2017-12-26T04:02:07.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://spacemacs.org/" target="_blank" rel="external">Spacemacs</a> 是一份 <a href="https://www.gnu.org/s/emacs/" target="_blank" rel="external">Emacs</a> 的配置文件，将 <a href="https://github.com/vim/vim" target="_blank" rel="external">Vim</a> 的快捷键移植到了 Emacs 上，可以提供 Vimer 至 Emacs 的无缝衔接。有了 Spacemacs，你不需要花那么多时间去学习 Emacs 就可以真正用 Spacemacs 开始做一些事情。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">$ mv ~/.emacs.d ~/.emacs.d.bak
$ git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
$ emacs
</code></pre>
<p>Clone 至本地后，第一次使用 Spacemacs 时要加载一些 Package，以及根据你的喜好所生成的配置，建议一路回车。</p>
<p>此时会加载很多的 Package，如果没有挂代理的话，就会很慢很慢，可以采用 <a href="https://elpa.emacs-china.org/" target="_blank" rel="external">emacs-china</a> 的配置源。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Spacemacs 基本使用的是原生 Vim 的快捷键，此前请先熟悉 Vim 的操作。我这里只贴出个人认为比较常用的快捷键。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>SPC f e d</code> 快速打开配置文件</p>
<p><code>SPC f e R</code> 同步配置文件</p>
<p><code>SPC q q</code> 退出 Emacs</p>
<p><code>SPC q R</code> 重启 Emacs</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>SPC f f</code> 打开文件</p>
<p><code>SPC f t</code> neotree 方式显示文件路径</p>
<p><code>Ctrl s</code> 搜索当前文件（需安装 ivy layer）</p>
<p><code>*</code> 另一种搜索文件的姿势（需将光标置于需搜索的单词处）</p>
<ul>
<li><code>n</code>  下一个匹配</li>
<li><code>N/p</code> 前一个匹配</li>
<li><code>r</code> 改变范围：当前屏幕，当前函数，当前 buffer</li>
<li><code>e</code> 编辑所有匹配（类似于替换）</li>
<li><code>/</code> 在当前 project 搜索</li>
</ul>
<p><code>SPC s c</code> 清除搜索高亮</p>
<p><code>SPC f R</code> 重命名当前文件</p>
<p><code>SPC f E</code> 使用 sudo 来编辑文件（当某些文件的权限是只读的时候）</p>
<p><code>SPC f D</code> 删除当前文件</p>
<p><code>SPC f r</code> 打开最近文件列表（需安装 ivy layer）</p>
<p><code>SPC f y</code> 复制当前文件的绝对路径</p>
<p><code>SPC f c</code> 复制文件</p>
<h3 id="buffer-管理"><a href="#buffer-管理" class="headerlink" title="buffer 管理"></a>buffer 管理</h3><p><code>SPC b b</code> 显示已经打开的 buffer</p>
<p><code>SPC b d</code> 关闭当前 buffer</p>
<p><code>SPC b h</code> 进入 Spacemacs 初始界面</p>
<p><code>SPC b N</code> 新建一个 buffer</p>
<p><code>SPC b R</code> 从自动备份的文件中恢复</p>
<p><code>SPC b Y</code> 复制整个 buffer 的内容</p>
<p><code>SPC b P</code> 将剪贴板的内容粘贴到整个 buffer</p>
<p><code>SPC Tab</code> 切换至上一个 buffer</p>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><code>SPC n(number)</code> 跳转至第 n 号窗口</p>
<p><code>SPC 0</code> 跳转至 neotree 侧边栏</p>
<p><code>SPC w m</code> 当前窗口最大化</p>
<p><code>SPC w s</code> 或 <code>SPC w -</code> 水平分割窗口</p>
<p><code>SPC w v</code> 或 <code>SPC w /</code> 竖直分割窗口</p>
<p><code>SPC w =</code> 平衡窗口</p>
<p><code>SPC w d</code> 删除当前窗口</p>
<p><code>SPC w o</code> 切换至其他窗口</p>
<p><code>SPC t g</code> 将当前窗口与其他窗口 黄金分割</p>
<h3 id="project-管理"><a href="#project-管理" class="headerlink" title="project 管理"></a>project 管理</h3><p><code>SPC p f</code> 在当前 project 中查找文件</p>
<p><code>SPC p p</code> 切换项目</p>
<p><code>SPC /</code> 在该项目中搜索字符串</p>
<p><code>SPC p R</code> 在项目中替换字符串，先输入「匹配」的，再输入「替换」的字符串（我一般不使用这种方式，我用<code>*</code>来替换）</p>
<h3 id="缩进代码"><a href="#缩进代码" class="headerlink" title="缩进代码"></a>缩进代码</h3><p><code>SPC j =</code> 自动对齐</p>
<p><code>SPC m =</code> 美化代码（不适用于所有语言）</p>
<h3 id="shell-操作"><a href="#shell-操作" class="headerlink" title="shell 操作"></a>shell 操作</h3><p><code>SPC &#39;</code> 打开/关闭 Eshell（需安装 shell layer）</p>
<p><code>SPC a s</code> 打开其它种类的 Shell</p>
<h3 id="中断操作"><a href="#中断操作" class="headerlink" title="中断操作"></a>中断操作</h3><p><code>C g</code> 输错命令时，可取消该次输入</p>
<h2 id="显示动态行号"><a href="#显示动态行号" class="headerlink" title="显示动态行号"></a>显示动态行号</h2><p>将  <code>dotspacemacs-line-numbers</code> 的值改为 ‘relative</p>
<h2 id="Magit"><a href="#Magit" class="headerlink" title="Magit"></a>Magit</h2><p>Spacemacs 中集成了 Git 管理工具，需先安装 git layer。</p>
<p>常用的快捷键：</p>
<table>
<thead>
<tr>
<th>git</th>
<th>magit</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git init</code></td>
<td><code>SPC g i</code></td>
</tr>
<tr>
<td><code>git status</code></td>
<td><code>SPC g s</code></td>
</tr>
<tr>
<td><code>git add</code></td>
<td><code>SPC g s</code> 弹出然后按 <code>s</code></td>
</tr>
<tr>
<td><code>git add currentfile</code></td>
<td><code>SPC g</code></td>
</tr>
<tr>
<td><code>git commit</code></td>
<td><code>SPC g c c</code></td>
</tr>
<tr>
<td><code>git push</code></td>
<td><code>SPC g P</code></td>
</tr>
<tr>
<td><code>git log</code></td>
<td><code>SPC g l l</code></td>
</tr>
<tr>
<td><code>git checkout xxx</code></td>
<td><code>SPC gn C</code></td>
</tr>
<tr>
<td><code>git checkout -- xxx</code></td>
<td><code>SPC g s</code> 弹出然后按 <code>u</code></td>
</tr>
<tr>
<td><code>git reset --hard xxx</code></td>
<td><code>SPC g s</code> 弹出然后按 <code>x</code></td>
</tr>
</tbody>
</table>
<h2 id="守护模式"><a href="#守护模式" class="headerlink" title="守护模式"></a>守护模式</h2><p>终端使用 <code>emacs -daemon</code> 以守护模式开启 emacs：</p>
<p><code>$ emacsclient -c</code> 打开 Emacs GUI<br><code>$ emacsclient -t</code> 打开 命令行 Emacs</p>
<p>当开启守护进程时，点击关闭按钮后进程还是会保留在后台，如果想要彻底关闭 Emacs 可以：<code>SPC q q</code> 或者<code>$ killall emacs</code></p>
<p>以下是我针对我常用的一些语言做的一些特殊的设置：</p>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>我没有采用 Spacemacs 提供的 c/c++ layer，而是采用的 <a href="https://github.com/Sarcasm/irony-mode" target="_blank" rel="external">Irony-Mode</a>，因为原生的 c/c++ layer 自动补全需要 ycmd，而 ycmd 安装配置起来实在太麻烦了。</p>
<h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>:gdb</code> 启用 gdb 调试</p>
<p><code>SPC c C</code> 编译程序</p>
<ul>
<li>默认是用 <code>cmake</code> 编译，可以替换成 <code>clang/gcc -g main.C -o main</code> （这些参数会被记住）</li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python 用的 Spacemacs 自带的 python layer，添加了一些参数：</p>
<pre><code class="emacs-lisp">(python :variables
        python-enable-yapf-format-on-save t ;; 当保存的时候自动 `yapf&#39; 美化
        python-fill-column 80                ;; 开启 80 列的提示
        python-sort-imports-on-save t)        ;; 当保存的时候自动排序导入的包
</code></pre>
<h3 id="快捷键-2"><a href="#快捷键-2" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, c c</code> 运行当前文件</p>
<p><code>, =</code> 美化代码</p>
<p><code>, &#39;</code> 打开 IPython repl</p>
<p><code>, g</code> 跳转至定义处：</p>
<ul>
<li><code>, g g</code> 在当前窗口跳转至定义处</li>
<li><code>, g G</code> 在另一窗口跳转至定义处</li>
<li><code>, g b</code> 回到原处</li>
</ul>
<p><code>, s</code> 将当前文件发送至 repl:</p>
<ul>
<li><code>, s b</code> 将当前 buffer 发送至 repl</li>
<li><code>, s f</code> 将当前 defun 发送至 repl</li>
<li><code>, s r</code> 将当前选中内容发送至 repl</li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>我将 JavaScript layer 自带的 repl 换成了 nodejs，自带的不太好用。</p>
<pre><code class="emacs-lisp">(javascript :variables
            tern-command &#39;(&quot;node&quot; &quot;/home/wincer/.npm-global/bin/tern&quot;)    ;; 指定 `tern&#39; 的路径
            javascript-disable-tern-port-files nil)
</code></pre>
<p>设置了一些快捷键：(o 开始的默认为用户自定义的)</p>
<p><code>SPC o s i</code> 启动 nodejs repl</p>
<p><code>SPC o s b</code> 将当前 buffer 发送至 repl</p>
<p><code>SPC o s r</code> 将选中内容发送至 repl</p>
<p><code>SPC o s l</code> 将当前行发送至 repl</p>
<h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>我是在学 sicp 时才用到 Scheme，所以采用的 Scheme 实现是 MIT-Scheme，并将其设置为默认 repl：</p>
<h3 id="快捷键-3"><a href="#快捷键-3" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, &#39;</code> 切换至 repl</p>
<p><code>, s</code> 评估算式：</p>
<ul>
<li><code>, s b</code> 计算当前 buffer</li>
<li><code>, s e</code> 计算最后一个表达式</li>
<li><code>, s f</code> 计算当前定义的函数</li>
<li><code>, s r</code> 计算当前选中的内容</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我的 Spacemacs 配置放在了 GitHub 上，<a href="https://github.com/WincerChan/Spacemacs-Config" target="_blank" rel="external">这是地址</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://spacemacs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spacemacs&lt;/a&gt; 是一份 &lt;a href=&quot;https://www.gnu.org/s/emacs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Emacs&lt;/a&gt; 的配置文件，将 &lt;a href=&quot;https://github.com/vim/vim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vim&lt;/a&gt; 的快捷键移植到了 Emacs 上，可以提供 Vimer 至 Emacs 的无缝衔接。有了 Spacemacs，你不需要花那么多时间去学习 Emacs 就可以真正用 Spacemacs 开始做一些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Spacemacs" scheme="https://blog.itswincer.com/tags/Spacemacs/"/>
    
      <category term="编辑器" scheme="https://blog.itswincer.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从 HTTP 到 HTTPS 再到 HSTS</title>
    <link href="https://blog.itswincer.com/posts/dfc84766/"/>
    <id>https://blog.itswincer.com/posts/dfc84766/</id>
    <published>2017-09-13T02:05:33.000Z</published>
    <updated>2017-12-26T04:02:07.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的博客是在三个月前就完成了 <code>HTTPS</code> 加密工作，方式嘛，和大多数网站类似，是将 <code>HTTP</code> 的请求 301 跳转至 <code>HTTPS</code>，这样虽然可以让用户即使输入的不包含 <code>HTTPS</code> 的网址，也可以跳转至 <code>HTTPS</code>。但是当你输入的是域名（不带 <code>HTTP</code> 或 <code>HTTPS</code> ）时，浏览器会自动帮助你填充的是 <code>HTTP</code> 而不是 <code>HTTPS</code>。</p>
<p>虽然正常情况你会跳转至 <code>HTTPS</code>，但是啊但是目前有一种称为「<strong>降级攻击</strong>」的技术（具体原理自行查阅），我这里简单说一下后果：这种技术是借助中间人发动的攻击，中间人会在浏览器和目标网站之间尝试拦截跳转至 <code>HTTPS</code> 的内容，将浏览器重定向至受攻击者控制的服务器，这也就是我们所说的「HTTP 请求劫持」。</p>
<p>那么怎么预防呢？</p>
<ol>
<li>在每个域名之前手动输入 <code>https://</code></li>
<li>网站启用 <code>HSTS</code></li>
</ol>
<p>第一种每次都要手写输入，自然很麻烦，第二点也就是本文所说的。</p>
<a id="more"></a>
<h2 id="HSTS-原理"><a href="#HSTS-原理" class="headerlink" title="HSTS 原理"></a>HSTS 原理</h2><p> <code>HSTS</code> 是 <code>HTTP Strict Transport Security</code> 的简称，定义在「<a href="https://tools.ietf.org/html/rfc6797" target="_blank" rel="external">RFC 6797</a> 」，旨在帮助使用 <code>HTTPS</code> 的服务器免受「<strong>降级攻击</strong>」。</p>
<p>工作流程如下：</p>
<ol>
<li>用户首次访问开启 <code>HSTS</code> 服务的网站</li>
<li>浏览器会留下一个包含 <code>max-age</code> 参数的 <code>HSTS</code> 缓存文件</li>
<li>在 <code>max-age</code> 到期之前访问网站，浏览器会根据缓存中的 <code>HSTS</code> 设置自动访问 <code>HTTPS</code> 页面</li>
</ol>
<p>开启 <code>HSTS</code> 后可以有效防止「<strong>降级攻击</strong>」，同时也会省去 301 至 <code>HTTPS</code> 的时间，于安全系数和用户体验都有提升。</p>
<h2 id="如何开启-HSTS"><a href="#如何开启-HSTS" class="headerlink" title="如何开启 HSTS"></a>如何开启 HSTS</h2><p>由于我的网站的 cdn 提供商 Cloudflare（CloudFlare 大法好！） 已经提供了 <code>HSTS</code> 技术，只需要手动开启就可以了。</p>
<p>在 <code>Crypto -&gt; HTTP Strict Transport Security (HSTS)</code>开启如下配置：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fjiuosceepj20r10903yy.jpg" alt=""></p>
<h3 id="安全系数检测"><a href="#安全系数检测" class="headerlink" title="安全系数检测"></a>安全系数检测</h3><p>开启之后，进入 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">https://www.ssllabs.com/ssltest/</a> 这个网站，输入域名后，该网站会对你的网站进行一次测试：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fjiuub5d6sj20rd0du3zd.jpg" alt=""></p>
<p>在开启后，我的网站安全等级变成了 A+，开启之前是 A。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在用户第一次访问时，如果输入网址没有 <code>HTTPS</code> 字段，无法避免的会进行一次 301 跳转，有可能还是会被攻击。</p>
<p>这个时候就需要用到 <a href="https://hstspreload.org/" target="_blank" rel="external">HSTS Preload</a> （本站域名已申请加入），这是由 Google 维护的一个域名列表，只要加入这个列表的域名，当使用主流浏览器，如：Chrome, Firefox, Opera, Safari, IE 11 和 Edge 时，即使第一次也会强制转换成 <code>HTTPS</code> 再访问。从而使访问更加安全。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我的博客是在三个月前就完成了 &lt;code&gt;HTTPS&lt;/code&gt; 加密工作，方式嘛，和大多数网站类似，是将 &lt;code&gt;HTTP&lt;/code&gt; 的请求 301 跳转至 &lt;code&gt;HTTPS&lt;/code&gt;，这样虽然可以让用户即使输入的不包含 &lt;code&gt;HTTPS&lt;/code&gt; 的网址，也可以跳转至 &lt;code&gt;HTTPS&lt;/code&gt;。但是当你输入的是域名（不带 &lt;code&gt;HTTP&lt;/code&gt; 或 &lt;code&gt;HTTPS&lt;/code&gt; ）时，浏览器会自动帮助你填充的是 &lt;code&gt;HTTP&lt;/code&gt; 而不是 &lt;code&gt;HTTPS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;虽然正常情况你会跳转至 &lt;code&gt;HTTPS&lt;/code&gt;，但是啊但是目前有一种称为「&lt;strong&gt;降级攻击&lt;/strong&gt;」的技术（具体原理自行查阅），我这里简单说一下后果：这种技术是借助中间人发动的攻击，中间人会在浏览器和目标网站之间尝试拦截跳转至 &lt;code&gt;HTTPS&lt;/code&gt; 的内容，将浏览器重定向至受攻击者控制的服务器，这也就是我们所说的「HTTP 请求劫持」。&lt;/p&gt;
&lt;p&gt;那么怎么预防呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在每个域名之前手动输入 &lt;code&gt;https://&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;网站启用 &lt;code&gt;HSTS&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种每次都要手写输入，自然很麻烦，第二点也就是本文所说的。&lt;/p&gt;
    
    </summary>
    
      <category term="博客栈" scheme="https://blog.itswincer.com/categories/%E5%8D%9A%E5%AE%A2%E6%A0%88/"/>
    
    
      <category term="安全" scheme="https://blog.itswincer.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="HSTS" scheme="https://blog.itswincer.com/tags/HSTS/"/>
    
  </entry>
  
  <entry>
    <title>爬虫模拟登录之一般性解决方法（Cookie）</title>
    <link href="https://blog.itswincer.com/posts/d68153f1/"/>
    <id>https://blog.itswincer.com/posts/d68153f1/</id>
    <published>2017-08-31T07:08:10.000Z</published>
    <updated>2017-12-26T04:02:07.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几周写了<a href="https://itswincer.com/posts/94e157f8/">一篇文章</a>，介绍了如何利用 post 方法来验证登录的问题，我也是一直在使用此方法登录豆瓣爬取一些信息，可是前两天突然就不能用了。我也再次查看了豆瓣的源代码，确认了豆瓣的验证信息并没有发生改变，但就是一直登录不上去，我猜想到可能是这个方法行不通了，于是我就换了一个思路：之前的思路是需要将 <code>post</code> 提交的表单数据保存在一个 <code>session</code> 的实例中，然后调用这个 <code>session</code> 实例的 <code>get</code> 方法就可以使用之前保存的数据。</p>
<p>而现在这一方法失效了，我猜想就是 <code>post</code> 方法提交数据这一步出了问题。那么就换一个思路，直接将服务器返回的数据存入 <code>session</code>，那么这个数据具体是什么？从哪儿来呢？这就是这篇文章所要谈到的。</p>
<a id="more"></a>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>这里简单说一下 Cookie 的作用，详细的定义见 <a href="https://www.ietf.org/rfc/rfc2109.txt" target="_blank" rel="external">RFC2109</a>。</p>
<blockquote>
<p>当登录一个网站的时候，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站，用户会发现没输用户名和密码就已经登录了。这是因为前一次登录时，服务器发送了包含登录凭据的 Cookie 到用户的硬盘里。下次登录时，如果 Cookie 尚未到期，那么浏览器就会发送该 Cookie，服务器验证凭据，于是就不需要用户名和密码就可以登录了。——维基百科</p>
</blockquote>
<p>也就是说我们只需要获取这个保存在硬盘中的 Cookie 信息，并将它传入程序可以登录了。</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>打开 Chrome 的开发工具的 Network 一栏，输入完用户名和密码及验证码后，点击登录。以简书为例（因为简书是需要滑动验证的，比豆瓣的验证码更麻烦）：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fj2y1160frj20n306vach.jpg" alt=""></p>
<p>你会发现有一个 <code>Type</code> 为 <code>document</code>、名为 <code>www.jianshu.com</code> 的文档，点开他并滑动到最下面你就会看到在 <code>Requests Header</code> 中有一项名为 <code>Cookie</code> 的很长很长的字符串，这里面就保存了你的登录信息，这些信息通常是经过加密的，所以不可读。Cookie 的格式一般是：<code>name1=value1;name2=value2</code>。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>那么获取了 Cookie 之后，该怎么在程序中使用呢？</p>
<p><code>requests</code> 库提供了<a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#session-objects" target="_blank" rel="external">这样的方法</a>，首先我们将从浏览器获取的 Cookie 的格式转换成 Python 的字典格式，如 <code>name1=value1;name2=value2</code> 转化为：</p>
<pre><code class="python">cookie = {
    &#39;name1&#39;: &#39;value1&#39;,
    &#39;name2&#39;: &#39;value2&#39;
}
</code></pre>
<p>然后，运用 <code>requests.get</code> 方法获取的时候将 cookie 传入就 OK 了：</p>
<pre><code class="python">from requests import get, session
# 这里最好设置一下User-Agent
head = {
    &#39;User-Agent&#39;:
    (&#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 &#39;
     &#39;(KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#39;)
}
url = &#39;http://www.jianshu.com&#39;
r = get(url, headers=head, cookies=cookie)
# 如果登录成功就会在首页的html中出现我的主页字样
r.text.find(&#39;我的主页&#39;)
</code></pre>
<p>有一点麻烦的是，每次都需要在 <code>get</code> 方法的参数列表中加入 headers 和 cookies 项，这样有点不利于我们书写，而且对爬取速度也有影响。那么有没有解决办法呢？</p>
<p>这里就要借用到上篇文章中使用的 <code>session</code> 机制，我们创建一个 <code>session</code> 的实例，首次 <code>get</code> 需要提交 headers 和 cookies，随后这些信息就会保存在创建的 <code>session</code> 实例中，下次直接调用实例的 <code>get</code> 方法，只需传入一个 url 即可。</p>
<pre><code class="python">ssion = session()
ss = ssion.get(url, headers=head, cookies=cookies)
&gt;&gt;&gt; ss.text.find(&#39;我的主页&#39;)
&gt;&gt;&gt; 5180
&gt;&gt;&gt; s = ssion.get(url)
&gt;&gt;&gt; s.text.find(&#39;我的主页&#39;)
&gt;&gt;&gt; 5180
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我之所以把这种方法成为一般性解决方法是因为这种方法的应用范围更广泛。上一篇文章介绍的方法仅适用于验证方式最为简单的网站（没有验证码或验证码是图片）而且失误率还高；本文介绍的方法相对来说就好了许多，唯一繁琐的一点可能就是将 cookies 转化为字典需要花费一点时间了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几周写了&lt;a href=&quot;https://itswincer.com/posts/94e157f8/&quot;&gt;一篇文章&lt;/a&gt;，介绍了如何利用 post 方法来验证登录的问题，我也是一直在使用此方法登录豆瓣爬取一些信息，可是前两天突然就不能用了。我也再次查看了豆瓣的源代码，确认了豆瓣的验证信息并没有发生改变，但就是一直登录不上去，我猜想到可能是这个方法行不通了，于是我就换了一个思路：之前的思路是需要将 &lt;code&gt;post&lt;/code&gt; 提交的表单数据保存在一个 &lt;code&gt;session&lt;/code&gt; 的实例中，然后调用这个 &lt;code&gt;session&lt;/code&gt; 实例的 &lt;code&gt;get&lt;/code&gt; 方法就可以使用之前保存的数据。&lt;/p&gt;
&lt;p&gt;而现在这一方法失效了，我猜想就是 &lt;code&gt;post&lt;/code&gt; 方法提交数据这一步出了问题。那么就换一个思路，直接将服务器返回的数据存入 &lt;code&gt;session&lt;/code&gt;，那么这个数据具体是什么？从哪儿来呢？这就是这篇文章所要谈到的。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="爬虫" scheme="https://blog.itswincer.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="模拟登录" scheme="https://blog.itswincer.com/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>写给 20 岁的自己</title>
    <link href="https://blog.itswincer.com/posts/11ab0263/"/>
    <id>https://blog.itswincer.com/posts/11ab0263/</id>
    <published>2017-08-28T16:00:00.000Z</published>
    <updated>2017-12-29T03:38:19.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>凡心所向，素履所往，生如逆旅，一苇以航。</p>
</blockquote>
<p>一直很喜欢海子对于时间的说法——“打马而过”。就像我还没来得及细数，20 个年头匆匆已逝。没有那么多时间细想，这一天就这么来临了，来不及回忆过去，也来不及憧憬未来，一眨眼，就发现自己已经 20 岁了。</p>
<p>在许久之前，我便对自己的 20 岁有过憧憬，想着，20 岁的我会在哪里，做着什么事情。是有了一项划时代的发明，成为震惊世界的奇才；还是偏居一隅，发出「天地与我并生 万物与我为一」的感慨。是的，我希望自己能真实的活着，不像那些忙忙碌碌一辈子不知道为谁而活的人那样。不在意别人的眼光，不为了生存而活。</p>
<a id="more"></a>
<p>但是，现在的我，也就只是在大学里，做着大多数人应该做的事情，过着大多数人应该过的生活。看来在这二十年的生命中，我还是不够坚韧。</p>
<p>我想我是不甘于于平凡的，很小的时候，我就会告诉自己，不要去重复别人做过的事情，因为我是独一无二的（后来才知道原来小孩都会有这样的想法），我有自己的事情去做。现在回想起来，还真的觉得挺可爱的。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fiotr9vjw3j21hc0u0asu.jpg" alt="搏击俱乐部" title="搏击俱乐部"></p>
<p>《搏击俱乐部》里泰勒抢了一个便利店员（雷蒙）的钱包并拿枪指着他的后脑勺，雷蒙跪在地上颤抖着，泰勒问他想做什么，同时扳下击锤，雷蒙颤抖得更厉害了。</p>
<p>“兽医”，雷蒙颤几乎是带着哭腔说了出来。</p>
<p>“我知道了，我要拿走你的驾照。我随时会去看你，我知道你住在哪”，泰勒说。</p>
<p>“要是在六星期内你没当上兽医，你就死定了”，泰勒把钱包还给他了，并让他跑回了家。</p>
<p>同行的杰克表示不理解：“拜托 那有什么好玩的？那样做有什么意义？”</p>
<p>泰勒背对着他，“明天会是他一生中最美的一天，他的早餐会比我们吃过的都甜美。”</p>
<hr>
<p>蒋勋在《孤独六讲》中写到，好像只有孤独，生命可以变得丰富而华丽。</p>
<p>无人理解的泰勒，他的人生想必是华丽到了极点。他内心所真正向往的地方是只有自己知晓的一方天地，他会去做自己想做的事，并因此让自己的生命变得有意义起来。</p>
<p>这一切都是因为做自己喜欢的事情，无关别人，只是为了自己的热爱。</p>
<p>从小到大，父母乃至老师灌输的思想就是：用心念书，从市重点初中，到省重点高中，再到一本大学，过更好的生活。</p>
<p>是的，过去二十年我仿佛就是按照这个既定的轨迹，一步一步活成了别人眼中的自己。等到我现在可以反思我的生活时，才发现<strong>我想做的事情</strong>和<strong>我应该做的事情</strong>那条清楚的界限早已模糊不清，长期的压力仿佛让自己对一切都失去了兴趣。</p>
<p>我抗争过吗？当然抗争过，不过一个人的力量终究是难以改变什么，泰勒也深知这一点，才会成立“搏击俱乐部”。</p>
<p>这样的生活很可怕。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fioxwob64dj21hc0u07wh.jpg" alt="三傻大闹宝莱坞" title="三傻大闹宝莱坞"></p>
<p>《三傻大闹宝莱坞》兰彻对法汗说：</p>
<blockquote>
<p>知道我为什么第一名吗？因为我热爱机械，工程学就是我的兴趣所在，知道你的兴趣吗？这就是你的兴趣……跟工程学说拜拜，跟摄影业结婚，发挥你的才能，想想迈克尔杰克逊的爸爸硬逼他成为拳击手，拳王阿里的爸爸非要他去唱歌，想想后果多可怕？</p>
</blockquote>
<p>是的，被别人强迫去做自己不喜欢的事情，是很可怕的。更可怕的是，被强迫的多了，就会麻木。</p>
<p>从小学到高中，我的生活一直像父母要求的那样，努力，不轻言放弃。被强迫穿着这许多外衣的我，沿着既定的轨迹一点一点的行进。</p>
<p>如果说，之前的我，不是为自己而活，那么从此时此刻，我就要像小时候自己想的那样，不为别人而活，为自己真实地活着。去寻找自己喜欢且甘之如饴的事情。</p>
<hr>
<p>作家吴晓波在《把生命浪费在美好的事情上》中写到：</p>
<blockquote>
<p>喜欢，是一切付出的前提。只有真心的喜欢了，你才会去投入，才不会抱怨这些投入，无论是时间、精力还是感情。</p>
<p>在这个世界上，不是每个国家每个时代每个家庭的年轻人，都有权利去追求自己所喜欢的未来，所以，如果你侥幸可以请千万不要错过。</p>
</blockquote>
<p>我还年轻，以后的路还很长，我可以做得更好。</p>
<p>不要害怕前路，我会迈着缓慢而坚定的步伐走下去。</p>
<p>我不要自己做到最好、最优秀，只希望能在接下来的时光里，变得柔软而坚韧。</p>
<p>最后，二十岁快乐，送给自己。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凡心所向，素履所往，生如逆旅，一苇以航。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一直很喜欢海子对于时间的说法——“打马而过”。就像我还没来得及细数，20 个年头匆匆已逝。没有那么多时间细想，这一天就这么来临了，来不及回忆过去，也来不及憧憬未来，一眨眼，就发现自己已经 20 岁了。&lt;/p&gt;
&lt;p&gt;在许久之前，我便对自己的 20 岁有过憧憬，想着，20 岁的我会在哪里，做着什么事情。是有了一项划时代的发明，成为震惊世界的奇才；还是偏居一隅，发出「天地与我并生 万物与我为一」的感慨。是的，我希望自己能真实的活着，不像那些忙忙碌碌一辈子不知道为谁而活的人那样。不在意别人的眼光，不为了生存而活。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="成长" scheme="https://blog.itswincer.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="感想" scheme="https://blog.itswincer.com/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>爬虫模拟登录</title>
    <link href="https://blog.itswincer.com/posts/94e157f8/"/>
    <id>https://blog.itswincer.com/posts/94e157f8/</id>
    <published>2017-08-13T03:34:20.000Z</published>
    <updated>2017-12-26T04:02:07.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>有时候就在想，要是所有的网站对爬虫友好该多好。</p>
</blockquote>
<p>当然这是不可能的：网站重要的数据往往就是一个产品的价值所在，如果被我们轻松的获取，这自然对网站经营者来说是一种损失，所以就有了以下各种策略去阻碍爬虫：</p>
<ul>
<li>User-Agent 检测</li>
<li>帐号及 Cookie 验证</li>
<li>验证码</li>
<li>限制 IP 次数或频率</li>
</ul>
<p>这篇文章主要来说说如何解决验证码问题。</p>
<a id="more"></a>
<h2 id="获取网页结构"><a href="#获取网页结构" class="headerlink" title="获取网页结构"></a>获取网页结构</h2><p>验证码多是在登录的情况下与 <code>username</code>、<code>password</code> 一同用 <code>post</code> 方法传给服务器进行验证，所以我们首先需要去查看一个网页的结构，这里以豆瓣为例：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fihz4nlx0vj20la06t75a.jpg" alt=""></p>
<p>检查元素后发现登录是单独存在的一个界面，网址是 <code>https://www.douban.com/accounts/login</code>，而且也标注了是以 <code>post</code> 去提交，接下来输入用户名和密码，点击登录，ok，我们就登录成功了，这是人为的方式，那么我们这种操作翻译成程序是怎么样的呢？</p>
<h3 id="检查-post-提交的信息"><a href="#检查-post-提交的信息" class="headerlink" title="检查 post 提交的信息"></a>检查 post 提交的信息</h3><p><code>F12</code> 打开调试工具，在 <code>Network</code> 一栏把 <code>Preserve log</code> 勾上，这一点是因为一点登录就跳转到另一个界面了，捕捉不到登录信息</p>
<p>随后你会看到加载了许多的信息，没关系，把滚动条拉至最上方，你会看到名为 <code>login</code> 的一个报文，点击，然后滑动到最下方，你就会看到一个 <code>Form Data</code> 的数据表，这就是 post 提交的东西，你会看到有包括你的邮箱、密码在内的 5 项内容，我们浏览器发送的也就是这 5 项。</p>
<h2 id="构造程序"><a href="#构造程序" class="headerlink" title="构造程序"></a>构造程序</h2><p>既然知道了需要提交的信息，也就成功了一大半了，这里用 requests 库的 session 来保存 cookie 信息</p>
<pre><code class="python">from requests import session

url = &#39;https://accounts.douban.com/login&#39;
#豆瓣貌似并不会验证User-Agent
head = {              
    &#39;User-Agent&#39;:
    (&#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 &#39;
        &#39;(KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#39;)
}
# 这里就是刚刚获取的post需要提交的信息
data = {                                        
    &#39;source&#39;: &#39;None&#39;,
    &#39;redir&#39;: &#39;https://www.douban.com&#39;,
    &#39;form_email&#39;: &#39;&#39;,
    &#39;form_password&#39;: &#39;&#39;,
    &#39;login&#39;: &#39;登录&#39;
}

ssion = session()
ssion.post(url, header=head, data=data)
</code></pre>
<p>用 <code>ssion.get()</code> 就可以使用刚刚保存在 session 中的信息进行登录了，你可以采取以下代码看看你是不是成功登录了：</p>
<pre><code class="python">t = ssion.get(&#39;https://www.douban.com&#39;).text
print(t)
</code></pre>
<p>如果你发现了自己的帐号名称，那么就成功了。</p>
<h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>大多数情况登录是不需要验证码的，但是亲测发现频繁登录大概 5 次左右就会需要验证码，同样检查 <code>post</code> 发现多了两项：</p>
<p><code>captcha-solution</code>、<code>captcha-id</code> 内容，自然就是我们输入的验证码了其中 <code>solution</code> 就是验证码的内容，<code>id</code> 就是验证码的编号，当二者与数据库的内容与编号对应时，就验证通过。</p>
<p>这里提供一个简单的思路：将验证码的图片保存至本地，然后用户输入验证码内容后再提交：</p>
<pre><code class="python">from re import search, compile
from PIL impoet Image

img = compile(r&#39;img id=&quot;captcha_image&quot; src=&quot;(.*?)&quot;&#39;)
img_url = img.findall(response)[0]
jpg = get(img_url).content
with open(&#39;captcha.jpg&#39;, &#39;wb&#39;) as f:
    f.write(jpg)
Image.open(&#39;captcha.jpg&#39;).show()
captcha_solu = input(&#39;input captcha: &#39;)
capt = compile(r&#39;captcha\?id=(.*?)\&amp;amp&#39;)
captcha_id = capt.findall(img_url)[0]
data = {
    &#39;source&#39;: &#39;None&#39;,
    &#39;redir&#39;: &#39;https://www.douban.com&#39;,
    &#39;form_email&#39;: &#39;&#39;,
    &#39;form_password&#39;: &#39;&#39;,
    &#39;captcha-solution&#39;: captcha_solu,
    &#39;captcha-id&#39;: captcha_id,
    &#39;login&#39;: &#39;登录&#39;
}
</code></pre>
<p>当你运行的时候，会弹出一个小框框显示的是验证码，在终端输入内容就可以了，如下图</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fii3teot8wj20p40m6adz.jpg" alt=""></p>
<p>用 class 封装一下，完整的代码见<a href="https://gist.github.com/WincerChan/3574fd7714e939d3d7ff4ac436c7371b" target="_blank" rel="external">这里</a>，main 函数返回的就是 <code>ssion</code>，直接使用即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;有时候就在想，要是所有的网站对爬虫友好该多好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然这是不可能的：网站重要的数据往往就是一个产品的价值所在，如果被我们轻松的获取，这自然对网站经营者来说是一种损失，所以就有了以下各种策略去阻碍爬虫：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User-Agent 检测&lt;/li&gt;
&lt;li&gt;帐号及 Cookie 验证&lt;/li&gt;
&lt;li&gt;验证码&lt;/li&gt;
&lt;li&gt;限制 IP 次数或频率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章主要来说说如何解决验证码问题。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="爬虫" scheme="https://blog.itswincer.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="模拟登录" scheme="https://blog.itswincer.com/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>再见 LiveRe，拥抱 Disqus</title>
    <link href="https://blog.itswincer.com/posts/e5d13eb/"/>
    <id>https://blog.itswincer.com/posts/e5d13eb/</id>
    <published>2017-07-29T02:08:32.000Z</published>
    <updated>2017-12-26T04:02:07.859Z</updated>
    
    <content type="html"><![CDATA[<p>没错，我又双叒叕换评论系统了，从最初的网易云跟帖，到后来的 LiveRe，再到现在的 Disqus，两个多月就换了好了三四次（中间从 LiveRe 切换过一次 Disqus，后来又换回来了）了，仿佛我在折腾这些非博客主体的路上越走越远，也幸好我的博客才建成，没啥人留言，不然就得不偿失了。</p>
<a id="more"></a>
<h2 id="LiveRe"><a href="#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>其实 LiveRe 真的做的挺棒的，中国的本地化做的更是没话说，支持国内的社交媒体：微信、QQ、百度、人人、豆瓣、新浪，国外的支持的就更多了，上次我因为评论框颜色的问题发送了邮件，结果不到 12 个小时 LiveRe 中国区的负责人亲自发邮件解答了这个疑问，就这点来说简直太良心了。</p>
<p>但是美中不足的是：</p>
<ol>
<li>不支持游客评论（其实这点倒无关紧要）</li>
<li>不支持导出评论</li>
<li>在我博客的加载速度问题</li>
</ol>
<p>我最不能忍受的就是第三点了，由于我博客是采用了 CloudFlare 的 Keyless SSL 技术，流量都会走 CloudFlare 的 CDN 节点，但是由于节点在国外，国内访问速度实在是太慢了（见下图），这简直不能忍啊，于是我就想做一个延时加载的，后来想想，既然都要做延时加载的了，那我为什么不干脆换成 Disqus 呢？</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fi0kzhd1o9j20xc0dzabx.jpg" alt=""></p>
<h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>那么说到 Disqus，之前为什么会不用 Disqus 呢，主要还是担心国内不会翻墙用户无法评论的问题，后来想想其实这点不重要，因为：</p>
<ol>
<li>我的博客只是在 <a href="https://www.google.com/webmasters/tools/home#utm_source=zh-CN-wmxmsg&amp;utm_medium=wmxmsg&amp;utm_campaign=bm&amp;authuser=0" target="_blank" rel="external">Google Search Console</a> 添加了信息，没有在百度站长平台添加，<del>所以百度是搜索不到我的网站</del>现在貌似已经可以搜到了；既然是从谷歌搜索进入的话，那自然也就不存在不会翻墙的问题了；</li>
<li>不是所有的用户都需要看评论，于是我就把评论功能隐藏了起来，需要的话点击下方按钮加载评论；</li>
</ol>
<p>这样优化过后，对比上一张图，国内部分地区速度果然提升了不少：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fi0lhcyoyvj20xc0dx760.jpg" alt=""></p>
<p>最后，列一下我对博客的优化：</p>
<ol>
<li>使用 glup 插件压缩 html、css、js、img 等；</li>
<li>CloudFlare 的 CDN 加速访问资源；</li>
<li>ServiceWorker 提供离线访问技术；</li>
<li>延时加载 Disqus 评论；</li>
</ol>
<p>每一点优化我都有写文章，文章链接可以通过搜索关键字获取。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没错，我又双叒叕换评论系统了，从最初的网易云跟帖，到后来的 LiveRe，再到现在的 Disqus，两个多月就换了好了三四次（中间从 LiveRe 切换过一次 Disqus，后来又换回来了）了，仿佛我在折腾这些非博客主体的路上越走越远，也幸好我的博客才建成，没啥人留言，不然就得不偿失了。&lt;/p&gt;
    
    </summary>
    
      <category term="博客栈" scheme="https://blog.itswincer.com/categories/%E5%8D%9A%E5%AE%A2%E6%A0%88/"/>
    
    
      <category term="博客" scheme="https://blog.itswincer.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Disqus" scheme="https://blog.itswincer.com/tags/Disqus/"/>
    
  </entry>
  
  <entry>
    <title>使用 Service Worker 优化网站</title>
    <link href="https://blog.itswincer.com/posts/a0df572f/"/>
    <id>https://blog.itswincer.com/posts/a0df572f/</id>
    <published>2017-07-25T05:06:47.000Z</published>
    <updated>2017-12-26T04:02:07.862Z</updated>
    
    <content type="html"><![CDATA[<p>静态博客的内容是很适合用缓存来加速访问的，除了采用常见的 CDN 加速和压缩博文等方法，通过客户端也可以实现加速访问，本文介绍的是「服务工作线程—— Service Worker」。关于 Service Worker 的具体介绍见<a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="external">这里</a>。本文主要需要的是它的离线加载的特性。</p>
<h2 id="启用-Service-Worker"><a href="#启用-Service-Worker" class="headerlink" title="启用 Service Worker"></a>启用 Service Worker</h2><h3 id="添加注册代码"><a href="#添加注册代码" class="headerlink" title="添加注册代码"></a>添加注册代码</h3><p>位置需要在网站的根目录添加，这样才能保证接管整个网站的全部资源。</p>
<a id="more"></a>
<pre><code class="javascript">&lt;script&gt;
if (&#39;serviceWorker&#39; in navigator) {
    navigator.serviceWorker.register(&#39;/sw.js&#39;);
}
&lt;/script&gt;
</code></pre>
<p>当然不是直接添加在生成的静态文件 <code>/public/index.html</code>，那样每次 <code>hexo g</code> 之后都会消失，太麻烦。我这里是放在了 <code>/next/layout/_thrid-party/comments/livere.swig</code>，因为我采用了 livere 的评论系统，当然你也可以不放在这里，只需要确保生成的 <code>/publuc/index.html</code> 包含上述代码就可以了。</p>
<h3 id="添加-Js-文件"><a href="#添加-Js-文件" class="headerlink" title="添加 Js 文件"></a>添加 Js 文件</h3><p>从<a href="https://gist.github.com/WincerChan/a553ea6ab3de0afc0d3945bbbccaebd3" target="_blank" rel="external">这里</a>下载所需文件 (sw.js)，需要添加如下文件在 <code>/source</code>目录下：</p>
<ul>
<li><code>sw.js</code></li>
<li><code>offline.svg</code></li>
<li><code>offline.html</code></li>
</ul>
<blockquote>
<p>离线后，用户依旧可以访问已缓存的页面。但是对于没有缓存的页面和图片，你可以通过 <code>offline.svg</code> 和 <code>offline.html</code> 加以提示。</p>
</blockquote>
<p>修改文件中的以下内容：</p>
<pre><code class="javascript">const matchFetch = [/https?:\/\/itswincer.com\//];
const ignoreFetch = [
  /https?:\/\/www.google-analytics.com\//,
  /https?:\/\/dn-lbstatics.qbox.me\//
];
</code></pre>
<p>具体看你的网站音引用了哪些资源可以打开 <code>Dev Tools</code> 的 <code>Source</code> 逐个筛选。</p>
<h3 id="是否成功？"><a href="#是否成功？" class="headerlink" title="是否成功？"></a>是否成功？</h3><p>同样在 <code>Dev Tools</code> 的 Application 选项卡中看到 <code>Service Workers</code> 就表示成功了。见下图</p>
<h2 id="加速效果"><a href="#加速效果" class="headerlink" title="加速效果"></a>加速效果</h2><h3 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h3><p>可以看到在启用了 <code>Offline</code> 仍然可以加载页面</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fhvzzyefwxg213l0mvawg.gif" alt="效果1"></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>刷新页面可以看到许多资源是直接 ( from ServiceWorker ) 加载的，大大提高载入速度。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fhw07svg0cg213l0bcwre.gif" alt="效果2"></p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p> <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="external">is Serviceworker ready</a> 详细列出了所有浏览器支持的情况。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fhw4volxvyj20qc09dacd.jpg" alt=""></p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>服务器工作线程只能工作在 HTTPS 加密的网站上，本地的 <code>localhost</code> 是默认安全。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://developer.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="external">服务工作线程：简介</a></li>
<li><a href="https://blog.nfz.moe/archives/wpo-by-service-worker.html" target="_blank" rel="external">Web 性能优化（1）——浅尝 Service Worker</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态博客的内容是很适合用缓存来加速访问的，除了采用常见的 CDN 加速和压缩博文等方法，通过客户端也可以实现加速访问，本文介绍的是「服务工作线程—— Service Worker」。关于 Service Worker 的具体介绍见&lt;a href=&quot;https://developers.google.com/web/fundamentals/getting-started/primers/service-workers&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。本文主要需要的是它的离线加载的特性。&lt;/p&gt;
&lt;h2 id=&quot;启用-Service-Worker&quot;&gt;&lt;a href=&quot;#启用-Service-Worker&quot; class=&quot;headerlink&quot; title=&quot;启用 Service Worker&quot;&gt;&lt;/a&gt;启用 Service Worker&lt;/h2&gt;&lt;h3 id=&quot;添加注册代码&quot;&gt;&lt;a href=&quot;#添加注册代码&quot; class=&quot;headerlink&quot; title=&quot;添加注册代码&quot;&gt;&lt;/a&gt;添加注册代码&lt;/h3&gt;&lt;p&gt;位置需要在网站的根目录添加，这样才能保证接管整个网站的全部资源。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="博客" scheme="https://blog.itswincer.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="优化" scheme="https://blog.itswincer.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="ServiceWorker" scheme="https://blog.itswincer.com/tags/ServiceWorker/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现多线程下载器</title>
    <link href="https://blog.itswincer.com/posts/80689c8d/"/>
    <id>https://blog.itswincer.com/posts/80689c8d/</id>
    <published>2017-07-19T06:53:24.000Z</published>
    <updated>2017-12-26T04:02:07.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我为什么会想到要写一个下载器呢，实在是被百度云给逼的没招了，之前用 Axel 配合直链在百度云下载视频能达到满速，结果最近两天 Axel 忽然不能用了，于是我就想着要不干脆自己写一个吧，就开始四处查询资料，这就有了这篇博客。</p>
<p>我假设阅读这篇博客的你已经对以下知识有所了解：</p>
<ul>
<li>Python 的文件操作</li>
<li>Python 的多线程</li>
<li>Python 的线程池</li>
<li>Python 的 requests 库</li>
<li>HTTP 报文的首部信息</li>
</ul>
<a id="more"></a>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>获取文件采用的是 requests 库，该已经封装好了许多 http 请求，我们只需要发送 get 请求，然后将请求的内容写入文件即可：</p>
<pre><code class="python">import requests

r = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;)
with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:
    f.write(r.content)
</code></pre>
<p>随后看看文件夹，那张名为 <code>wallpaper.png</code> 的图片就是我们刚刚下载的。</p>
<p>但是这个功能太简单了，甚至简陋，我们需要多线程并发执行下载各自的部分，然后再汇总。</p>
<h2 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h2><p>为了拆分，首先得知道数据块的大小，HTTP 报文首部提供了这样的信息：</p>
<ul>
<li>用 head 方法去获取 http 首部信息，再从获取的信息提取出 <code>Content-Length</code> 字段（上文图片大小为 261258 bytes）</li>
</ul>
<pre><code class="python">import requests

headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(0, 100000)}
r = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;, headers = headers)
with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:
    f.write(r.content)
</code></pre>
<p>我们得到了图片的前 100001 个字节（Range 的范围是包括起始和终止的），打开 <code>wallpaper.png</code> 你应该能看到一幅“半残”的图。</p>
<p>这样我们里目标更近了一步，继续：</p>
<ul>
<li>确认线程数（比如 8 个），261258//8 = 32657，前 7 个线程都取 32657 个 bytes，第八个取剩余的</li>
</ul>
<pre><code class="python">part = size // nums

for i in range(nums):
        start = part * i
        if i == num_thread - 1:   # 最后一块
            end = file_size
        else:
            end = start + part
</code></pre>
<ul>
<li>每个线程获取到的内容按顺序写入文件（file.seek() 调节文件指针）</li>
</ul>
<pre><code class="python">def down(start, end):
    headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}
    # 这里最好加上 stream=True，避免下载大文件出现问题
    r = requests.get(self.url, headers=headers, stream=True)
    with open(filename, &quot;wb+&quot;) as fp:
        fp.seek(start)
        fp.write(r.content)
</code></pre>
<p>嘛，线程多了起来就扔到线程池让它来帮我们调度。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>功能复杂了，用对象来封装整理一下：</p>
<pre><code class="python">class Downloader(): 
    def __init__(self, url, num, name):
        self.url = url
        self.num = num
        self.name = name
        r = requests.head(self.url)
        self.size = int(r.headers[&#39;Content-Length&#39;]) 

    def down(self, start, end):

        headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}
        r = requests.get(self.url, headers=headers, stream=True)

        # 写入文件对应位置
        with open(self.name, &quot;rb+&quot;) as f:
            f.seek(start)
            f.write(r.content)


    def run(self):
        f = open(self.name, &quot;wb&quot;)
        f.truncate(self.size)
        f.close()

        futures = []
        part = self.size // self.num 
        pool = ThreadPoolExecutor(max_workers = self.num)
        for i in range(self.num):
            start = part * i
            if i == self.num - 1:   
                end = self.size
            else:
                end = start + part - 1
            # 扔进线程池
            futures.append(pool.submit(self.down, start, end))
        wait(futures)
</code></pre>
<p>至此，核心功能都完成了，剩下的就是实际体验的优化了。</p>
<p>完整的代码已托管至 GitHub，地址见<a href="https://github.com/WincerChan/Py-Downloader" target="_blank" rel="external">这里</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很可惜，我写的这个下载器还是不能下载百度云直链，不过嘛，好多人都说结果不重要，都说重要的是过程，不是么？写这个下载器我也确实学到了许多，至于一开始我是出于什么样的目的？管他呢</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我为什么会想到要写一个下载器呢，实在是被百度云给逼的没招了，之前用 Axel 配合直链在百度云下载视频能达到满速，结果最近两天 Axel 忽然不能用了，于是我就想着要不干脆自己写一个吧，就开始四处查询资料，这就有了这篇博客。&lt;/p&gt;
&lt;p&gt;我假设阅读这篇博客的你已经对以下知识有所了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 的文件操作&lt;/li&gt;
&lt;li&gt;Python 的多线程&lt;/li&gt;
&lt;li&gt;Python 的线程池&lt;/li&gt;
&lt;li&gt;Python 的 requests 库&lt;/li&gt;
&lt;li&gt;HTTP 报文的首部信息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://blog.itswincer.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么学习算法</title>
    <link href="https://blog.itswincer.com/posts/af991767/"/>
    <id>https://blog.itswincer.com/posts/af991767/</id>
    <published>2017-07-16T09:12:22.000Z</published>
    <updated>2017-12-26T04:02:07.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于算法，我个人的心情是挺复杂的，去年的时候有去刷过一段时间的 ACM 算法题，后来就不知怎么荒废了，直到最近看「SICP」才决定捡起来，这篇文章也算是对算法的一点感想。</p>
<h2 id="增长的阶"><a href="#增长的阶" class="headerlink" title="增长的阶"></a>增长的阶</h2><p>不同计算过程在消耗计算资源速率可能存在巨大差异。为了描述这些差异的一种方法是采用「增长的阶」的记法，分析这一过程消耗的资源也就是我们平时所说的「算法分析」。</p>
<p>「令 $n$ 为一个参数，它能作为问题规模的一种度量，令 $R(n)$ 是一个计算过程在处理规模为 n 的问题时所需要的资源量。</p>
<p>我们称 $R(n)$ 具有 $\Theta(f(n))$ 的增长阶，记为 $R(n)=Θ(f(n))$，如果存在与 $n$ 无关的整数 $k_1$ 和 $k_2$，使得：$k_1f(n)\leq R(n)\le k_2f(n)$ 对于足够大的$n$值都成立。」<br><a id="more"></a><br>有了增长的阶的定义，我们就可以对一个过程所需资源有较具体的描述，例如：在上篇<a href="https://www.itswincer.com/posts/aabe7c53/" target="_blank" rel="external">博客</a>描述的线性递归计算过程中，步骤数目增长正比于输入 $n$。也就是说，这一计算过程所需步骤增长为 $Θ(n)$，其空间需求也是 $Θ(n)$。迭代的阶乘，其步数还是 $Θ(n)$ 而空间是 $Θ(1)$，即为一个常数。本文介绍的树形递归的「斐波那契」计算需要 $Θ(\phi^n)$ 步骤和 $Θ(n)$ 的空间。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面这个定义给定基数 $b$ 和正整数指数 $n$ 来计算 $b^n$：</p>
<p>$b^n=b\cdot b^{n-1}$</p>
<p>$b^0=1$</p>
<p>可以直接翻译成如下过程：</p>
<pre><code class="lisp">(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
</code></pre>
<p>这是一个线性的递归计算过程，需要 $Θ(n)$ 步和 $Θ(n)$ 空间。就像阶乘和「斐波那契」，我们很容易将其形式化为一个等价的线性迭代：</p>
<pre><code class="lisp">(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
</code></pre>
<p>这一版本需要 $Θ(n)$ 步和 $Θ(1)$ 空间。这一算法自然比一算法更好，复杂度更低，那么，还能更优化吗？</p>
<p>我们可以采用递归的思想，把问题转化为规模较小的子问题。例如：不是以采用下面这样的方式算 $b^8$：</p>
<p>$b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot(b\cdot b))))))$</p>
<p>而是用连续求平方，以更少的步骤完成计算：<br>$b^8=b^4\cdot b^4$<br>$b^4=b^2\cdot b^2$<br>$b^2=b\cdot b$</p>
<p>这一方法对于指数是 2 的乘幂都可以用。如果采用下面规则，我们就可以借助于连续求平方，来完成一般性的乘幂运算：</p>
<p>$b^n=(b^{n/2})^2$                若 $n$ 是偶数</p>
<p>$b^n=b\cdot b^{n-1}$                若 $n$ 是奇数</p>
<p>这一方法翻译为如下程序：</p>
<pre><code class="lisp">(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
(define (even? n)
  (= (remainder n 2) 0))
</code></pre>
<p>这一计算过程，在空间和步数上相对于 $n$ 都是对数的：用 <code>fast-expt</code> 计算 $b^{2n}$的时候，只需要比 $b^n$ 多做一次乘法。能够计算的指数值大约增长一倍。这样，计算指数 $n$ 所需要乘法次数增长大约以 $2$ 为底 $n$ 的对数值，这一计算过程增长的阶为 $\Theta(log\ n)$。</p>
<p>随着 $n$ 变大，$\Theta(log\ n)$ 增长与 $\Theta(n)$ 增长差异会变得非常明显。当 $n =1000$ 时，<code>fast-expt</code> 只需要 $14$ 次乘法。</p>
<p>当然，我们同样可以通过连续求平方的方法，设计一个对数步数的计算乘幂的迭代算法：</p>
<pre><code class="lisp">(define (even? n)
 (= (remainder n 2) 0))

(define (fast-expt b n)
 (fast-expt-iter b n 1))

(define (fast-expt-iter b counter product)
 (cond ((= counter 0) 1)
       ((even? counter) (square (fast-expt-iter b (/ counter 2) (* product b))))
       (else (* b (fast-expt-iter b (- counter 1) (* product b))))))
</code></pre>
<p>这一计算过程需要 $\Theta(log\ n)$ 步，$\Theta(1)$ 空间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你越努力的去思考、将算法的复杂度降的越低，算法应用于程序所占用的资源就越少，尽管该程序会不那么直截了当，但这是值得的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于算法，我个人的心情是挺复杂的，去年的时候有去刷过一段时间的 ACM 算法题，后来就不知怎么荒废了，直到最近看「SICP」才决定捡起来，这篇文章也算是对算法的一点感想。&lt;/p&gt;
&lt;h2 id=&quot;增长的阶&quot;&gt;&lt;a href=&quot;#增长的阶&quot; class=&quot;headerlink&quot; title=&quot;增长的阶&quot;&gt;&lt;/a&gt;增长的阶&lt;/h2&gt;&lt;p&gt;不同计算过程在消耗计算资源速率可能存在巨大差异。为了描述这些差异的一种方法是采用「增长的阶」的记法，分析这一过程消耗的资源也就是我们平时所说的「算法分析」。&lt;/p&gt;
&lt;p&gt;「令 $n$ 为一个参数，它能作为问题规模的一种度量，令 $R(n)$ 是一个计算过程在处理规模为 n 的问题时所需要的资源量。&lt;/p&gt;
&lt;p&gt;我们称 $R(n)$ 具有 $\Theta(f(n))$ 的增长阶，记为 $R(n)=Θ(f(n))$，如果存在与 $n$ 无关的整数 $k_1$ 和 $k_2$，使得：$k_1f(n)\leq R(n)\le k_2f(n)$ 对于足够大的$n$值都成立。」&lt;br&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="SICP" scheme="https://blog.itswincer.com/tags/SICP/"/>
    
      <category term="递归" scheme="https://blog.itswincer.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="算法" scheme="https://blog.itswincer.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>树形递归</title>
    <link href="https://blog.itswincer.com/posts/99a81f4c/"/>
    <id>https://blog.itswincer.com/posts/99a81f4c/</id>
    <published>2017-07-16T04:08:17.000Z</published>
    <updated>2017-12-26T04:02:07.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树形递归"><a href="#树形递归" class="headerlink" title="树形递归"></a>树形递归</h2><p>与上一篇介绍的「<a href="https://www.itswincer.com/posts/aabe7c53/" target="_blank" rel="external">线性递归</a>」类似的另一种常见计算模式为「树形递归」。本质嘛，可以看作许多分支的线性递归。</p>
<p>还是直接上具体的例题。</p>
<p>「斐波那契数列<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="external">^1</a>」的定义如下<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ws1.sinaimg.cn/large/ba22af52gy1fhltrol0xxj20j102iwee.jpg" alt="v"></p>
<p>看到这个定义我们马上就能把它编写成程序：</p>
<pre><code class="lisp">(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</code></pre>
<a id="more"></a>
<p>这个程序完全就是按照定义来的，定义怎么说我就怎么写，不需要什么额外的思考。</p>
<p>来分析一下，如果我们需要计算 <code>(fib 5)</code>，就需要计算出 <code>(fib 4)</code> 和 <code>(fib 3)</code>。而为了计算 <code>(fib 4)</code>，又需要计算出 <code>(fib 3)</code> 和 <code>(fib 2)</code>。将这一过程展开后会像一棵数，如下图所示。这里的每一层都分裂为两个分支（除了最下面），也就是说对 <code>fib</code> 函数的每个调用中都包含了两次调用自身。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://mitpress.mit.edu/sicp/full-text/book/ch1-Z-G-13.gif" alt="fib"></p>
<p>这是一个很经典的树形递归的例子，但是它的计算效率太低了，做了太多的冗余计算。在图中求 <code>(fib 3)</code> 这个过程重复了 2 次。或者更明白的说：<code>Fib(n)</code> 值的增长对于 <code>n</code> 是指数的。<code>Fib(n)</code> 是最接近 $\phi^n/\sqrt5$ 的整数，其中 $\phi$ 满足 $\phi^2=\phi+1$，证明过程见<a href="https://github.com/WincerChan/sicp/blob/master/chapter1/e1.13.png" target="_blank" rel="external">这里</a>。</p>
<p>也就是说这个 <code>Fib(n)</code> 计算过程随着输入 <code>n</code> 的增长而指数性增长。而空间需求是线性增长，为什么呢？因为在计算中的每一点，我们只需要保存树中在此之上节点的轨迹。具体的，当我们所处的位置是 <code>Fib(3)</code> 的时候，只需要保存的轨迹是如何到达 <code>Fib(3)</code> 的就行了，至于后续是如何的，那不是当前 <code>Fib(3)</code> 所需要考虑的。</p>
<p>一般说，树形递归计算过程所需的步骤数正比于树中的结点数，其空间需求正比于数的最大深度。</p>
<h2 id="迭代转化"><a href="#迭代转化" class="headerlink" title="迭代转化"></a>迭代转化</h2><p>我们当然可以规划一种迭代计算过程来计算「斐波那契数列」，基本想法是用一对整数 $a$ 和 $b$，将它们分别初始化为 <code>Fib(1)=1</code> 和 <code>Fib(0)=0</code>，而后反复使用下面规则变换：</p>
<p>$a\longleftarrow a+b$</p>
<p>$b\longleftarrow a$</p>
<p>在应用了这些变换后，$a$ 和 $b$ 将分别等于 <code>Fib(n+1)</code> 和 <code>Fib(n)</code>。因此，我们可以编成以下程序：</p>
<pre><code class="lisp">(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
</code></pre>
<p>这种方法的计算步骤相对于 $n$ 来说是线性的，与上一个方法差距巨大。那么，到底有多大呢？我们编写一个程序测试：</p>
<pre><code class="lisp">(define (Fibo n start)
  (fib n)
  (- (real-time-clock) start))

;递归方法：(单位为ms)
1 ]=&gt; (Fibo 30 (real-time-clock))
;Value: 1214

1 ]=&gt; (Fibo 31 (real-time-clock))
;Value: 1735

1 ]=&gt; (Fibo 32 (real-time-clock))
;Value: 2793

;迭代方法：
1 ]=&gt; (Fibo 1000 (real-time-clock))
;Value: 1

1 ]=&gt; (Fibo 5000 (real-time-clock))
;Value: 6

1 ]=&gt; (Fibo 10000 (real-time-clock))
;Value: 13
</code></pre>
<p>当然这个并不严谨，实际的算法分析还是要根据数学公式推导、证明，但足以让我们感受到这二者方法的 天差地别。</p>
<p>当然也不能说树形递归计算过程根本没有用。因为树形递归计算过程可以帮助我们理解和设计程序。以「斐波那契数列」为例，虽然第一个方法远比第二个低效，但却更加直截了当，基本就是把定义翻译成了 Lisp 语言。</p>
<p><strong>本文系本人阅读 SICP 时所做的笔记，全部笔记可在标签 SICP 中查看</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树形递归&quot;&gt;&lt;a href=&quot;#树形递归&quot; class=&quot;headerlink&quot; title=&quot;树形递归&quot;&gt;&lt;/a&gt;树形递归&lt;/h2&gt;&lt;p&gt;与上一篇介绍的「&lt;a href=&quot;https://www.itswincer.com/posts/aabe7c53/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;线性递归&lt;/a&gt;」类似的另一种常见计算模式为「树形递归」。本质嘛，可以看作许多分支的线性递归。&lt;/p&gt;
&lt;p&gt;还是直接上具体的例题。&lt;/p&gt;
&lt;p&gt;「斐波那契数列&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;」的定义如下&lt;img src=&quot;https://ws1.sinaimg.cn/large/ba22af52gy1fhltrol0xxj20j102iwee.jpg&quot; alt=&quot;v&quot;&gt;&lt;/p&gt;
&lt;p&gt;看到这个定义我们马上就能把它编写成程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lisp&quot;&gt;(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="SICP" scheme="https://blog.itswincer.com/tags/SICP/"/>
    
      <category term="递归" scheme="https://blog.itswincer.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>谈谈递归和迭代</title>
    <link href="https://blog.itswincer.com/posts/aabe7c53/"/>
    <id>https://blog.itswincer.com/posts/aabe7c53/</id>
    <published>2017-07-10T05:34:28.000Z</published>
    <updated>2017-12-26T04:02:07.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首次接触递归（recursion）这个概念是在学习 C 语言的时候，当时老师是根据「汉诺塔」<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94" target="_blank" rel="external">^1</a>这一具体问题的求解来介绍递归这个概念，至于迭代（iterate），好像 C 语言老师压根没提这个概念，第一次是在 MIT 的 Python 导论中听说的，但当时听完之后也只是对迭代和递归只有极其有限的了解。正好借着 SICP，好好弄清楚二者的概念。</p>
<p>首先明确二者的概念：</p>
<ul>
<li><p>递归：是指在函数的定义中使用函数自身的方法。</p>
</li>
<li><p>迭代：迭代是程序中对一组指令（或一定步骤）的重复。在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</p>
</li>
</ul>
<a id="more"></a>
<p>循环，则是一种更宽泛的概念，凡是重复执行的一段代码，都可以称之循环，它是作为一种控制流程存在的，它与递归和迭代不同，个人认为递归和迭代更像是一种算法思想，而循环结构则是这种思想在程序中的一种体现方式。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>用一个具体的题目来说明一下。</p>
<p>定义一个阶乘函数：<br>$$n!=n\times(n-1)\times(n-2)\times\cdots\times3\times2\times1$$<br>有一种很容易想到的计算方式就是：对于一个正整数 $n$，$n!$ 就等于 $n$ 乘以 $(n-1)!$:<br>$$n!=n\times[(n-1)\times(n-2)\times\cdots\times3\times2\times1]=n\times(n-1)!$$<br>这样我们就能通过算出 $(n-1)!$，并将其结果乘以 $n$ 的方式来计算出 $n!$。再注意到 $1!$ 就是 $1$，我们就可以出编写一个程序：</p>
<pre><code class="lisp">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</code></pre>
<p>我们采取代换模型分析以下当这个程序在计算 $6!$ 时的具体过程。</p>
<pre><code class="lisp">(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
</code></pre>
<p>递归的代换模型显示的是一种逐步展开而后收缩的形状。在展开的阶段中，这一计算过程构造了一个「推迟进行」的操作所形成的链条，收缩阶段表现为这些运算的实际执行。这种类型的计算过程由一个「推迟进行」的运算链条刻画，称之为「递归计算过程」。</p>
<p>要执行这种计算过程，解释器（或者编译器）就需要保护好那些以后将要执行的操作的轨迹。</p>
<p>在计算 $n!$ 时，推迟执行的乘法链条的长度就是为保存其轨迹需要保存的信息量，这个长度随着 $n$ 值而线性增长，就像计算中的步骤数目一样。这样的计算过程成为<strong>线性递归过程</strong>。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>我们同样可以将计算阶乘$n!$的规则描述为：先乘 $1$ 和 $2$，而后将结果乘以 $3$，而后再乘以 $4$，这样下去直到到达 $n$。更程序化的说，我们要保存一个变动的乘积 <code>product</code>，以及一个从 $1$ 到 $n$ 的计数器 <code>counter</code>，这一计算过程可以描述为 <code>counter</code> 和 <code>product</code> 的如下变化，每一步都按照如下变化<br>​     $$product \longleftarrow counter\times product$$<br>​     $$counter \longleftarrow counter+1$$<br>可以看到，$n!$ 也就是当 <code>counter</code> 超过 $n$ 的时候成绩 <code>product</code> 的值。</p>
<p>将上述描述编写成程序：</p>
<pre><code class="lisp">(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</code></pre>
<p>与递归类似，同样采取代换模型来查看 $6!$ 详细过程：</p>
<pre><code class="lisp">(factorial 6)
(factorial 1 1 6)
(factorial 1 2 6)
(factorial 2 3 6)
(factorial 6 4 6)
(factorial 24 5 6)
(factorial 120 6 6)
(factorial 720 7 6)
</code></pre>
<p>迭代的计算过程并没有任何增长或者收缩。对于任意一个 $n$，在计算过程中的每一步，我们所需要保存的就只有变量 <code>product</code>、<code>counter</code>、<code>max-count</code> 的<strong>当前值</strong>。这种过程就称为「迭代计算过程」。</p>
<p>「迭代计算过程」就是状态可以用固定数目的变量来描述的计算过程，但不仅仅如此，还需要一套规则来描述计算过程从这个状态到下一状态转换时，这些变量的更新方式以及结束时的检测。</p>
<p>在计算 $n!$ 的时候，所需计算步骤随着 $n$ 线性增长，这种过程成为<strong>线性迭代过程</strong>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在做迭代和递归之间比较的时候，我们需要注意「递归计算过程」和「递归过程」的概念。当我们说一个程序是递归的时候，论述的是一个程序在语法层面上的一种形式：（直接或者间接地）引用了该程序的本身。在说某一计算过程具有某种模式时，我们说的是这一计算过程的进展方式（如，先伸展后收缩等等），而不是书写相应程序所体现的语法形式。</p>
<p>我们可以说 <code>fact-iter</code> 是一个递归过程（调用了自身），但是 <code>fact-iter</code> 产生的是一个迭代的计算过程，这么说可能会感觉很不舒服，甚至第一次听还会觉得这句话是错误的。但是这一计算过程确实是迭代的，因为它的状态由三个变量刻画就足够了。</p>
<p><strong>本文系本人阅读 SICP 时所做的笔记，全部笔记可在标签 SICP 中查看</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首次接触递归（recursion）这个概念是在学习 C 语言的时候，当时老师是根据「汉诺塔」&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;^1&lt;/a&gt;这一具体问题的求解来介绍递归这个概念，至于迭代（iterate），好像 C 语言老师压根没提这个概念，第一次是在 MIT 的 Python 导论中听说的，但当时听完之后也只是对迭代和递归只有极其有限的了解。正好借着 SICP，好好弄清楚二者的概念。&lt;/p&gt;
&lt;p&gt;首先明确二者的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归：是指在函数的定义中使用函数自身的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;迭代：迭代是程序中对一组指令（或一定步骤）的重复。在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="SICP" scheme="https://blog.itswincer.com/tags/SICP/"/>
    
      <category term="递归" scheme="https://blog.itswincer.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="迭代" scheme="https://blog.itswincer.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>Python 的迭代器和生成器</title>
    <link href="https://blog.itswincer.com/posts/903c6509/"/>
    <id>https://blog.itswincer.com/posts/903c6509/</id>
    <published>2017-07-02T04:03:42.000Z</published>
    <updated>2017-12-26T04:02:07.856Z</updated>
    
    <content type="html"><![CDATA[<p>我最初接触 Python 是在 17 年 2 月份，现在半年过去了，对迭代器和生成器的概念却及其有限，其实也是因为其它主流语言如：C、Java 中没有生成器的概念，所以当时学了就忘了。现在正准备好好复习一下迭代器和生成器。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代（即可以通过 <code>for</code> 循环去遍历）获取，可以用 <code>in</code>，<code>not in</code> 关键字判断元素是否包含在容器中。</p>
<p>在 Python 中，常见的容器对象有：</p>
<ul>
<li>list, deque</li>
<li>set, frozensets</li>
<li>dict, defaultdict, OrderedDict, Counter</li>
<li>tuple, namedtuple</li>
<li>str</li>
</ul>
<a id="more"></a>
<p>容器的概念比较容易理解，你可以把它看作一个盒子、一间屋子，里面可以塞许多东西。从某种意义来说，当它可以被询问某个元素是否包含在其中时，那么它就可以认为是一个容器。比如 <code>list</code>、<code>set</code>、<code>tuple</code> 等都是容器对象：</p>
<pre><code class="python">&gt;&gt;&gt; assert 1 in [1, 2, 3]    
&gt;&gt;&gt; assert 4 not in [1, 2, 3]
&gt;&gt;&gt; assert 1 in {1: &#39;foo&#39;, 2: &#39;bar&#39;, 3: &#39;qux&#39;}
&gt;&gt;&gt; assert &#39;foo&#39; not in {1: &#39;foo&#39;, 2: &#39;bar&#39;, 3: &#39;qux&#39;}  
&gt;&gt;&gt; assert &#39;b&#39; in &#39;foobar&#39;
&gt;&gt;&gt; assert &#39;x&#39; not in &#39;foobar&#39;
</code></pre>
<p>尽管绝大多数容器都提供了迭代的方式来获取其中每一个元素，但这并不是容器本身的能力，而是当容器对象需要提供迭代功能的时候，<strong>可迭代对象</strong>赋予了容器这种能力。</p>
<h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><p>迭代器协议是指对象需要提供 <code>__iter__()</code>、<code>__next__()</code> 方法，其中：</p>
<ul>
<li><code>__iter__()</code>返回迭代器对象本身</li>
<li><code>__next__()</code>从容器中返回迭代中的下一项，要么引起一个 <code>StopIteration</code> 异常，以终止迭代</li>
</ul>
<p>而迭代器对象就是实现了迭代器协议的对象。</p>
<pre><code class="python">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = x.__iter__()
&gt;&gt;&gt; type(x)
&lt;class &#39;list&#39;&gt;
&gt;&gt;&gt; next(x)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;list&#39; object is not an iterator
&gt;&gt;&gt; type(y)
&lt;class &#39;list_iterator&#39;&gt;
&gt;&gt;&gt; next(y)
1
</code></pre>
<p>这里的 <code>x</code> 就是一个可迭代对象（但并不是一个迭代器，注意看报错），可迭代对象和容器一样是一种通俗的叫法，不是某种具体的数据类型。<code>y</code> 是一个迭代器，具体来说 <code>y</code> 的迭代器类型是 <code>list_iterator</code>。可迭代对象实现了 <code>__iter__()</code>，该方法返回一个迭代器对象。</p>
<p>对 Python 稍微熟悉的朋友应该知道，<code>for</code> 循环不但可以用来遍历 <code>list</code>，还可以来遍历文件对象：</p>
<pre><code class="python">&gt;&gt;&gt; f = open(&#39;test.txt&#39;, &#39;r&#39;) 
&gt;&gt;&gt; type(f)
&lt;_io.TextIOWrapper name=&#39;test.txt&#39; mode=&#39;r&#39; encoding=&#39;UTF-8&#39;&gt;
&gt;&gt;&gt; for line in f:
        print(line)
...
&gt;&gt;&gt; next(f)
...
</code></pre>
<p>为什么在 Python 中，文件还可以使用 <code>for</code> 循环遍历呢，这是因为文件对象实现了迭代器协议，<code>for</code> 循环并不知道它遍历的是一个文件爱呢对象，它只需要使用迭代器协议访问对象即可。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>那么什么才是迭代器呢？它是一个带状态的对象，能在调用 <code>next()</code> 方法的时候返回容器下一个值，任何遵循了迭代器协议的对象都是迭代器。</p>
<p>为了更直观感受迭代器内部执行，我们自己定义一个迭代器，以斐波那契数列为例：</p>
<pre><code class="python">class Fib:
    def __init__(self):
        self.prev, self.curr = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        value = self.curr
        self.curr += self.prev
        self.prev = value
        return value

&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f
&lt;__main__.Fib object at 0x7f383fbdd438&gt;
&gt;&gt;&gt; for x in range(5):
...     next(f)
... 
1
1
2
3
5
</code></pre>
<p>Fib 既是一个可迭代对象（实现了 <code>__iter()</code> 方法），又是一个迭代器（实现了 <code>__next__()</code> 方法）。变量 <code>prev</code> 和 <code>curr</code> 用户维护迭代器内部的状态。每次调用 <code>next()</code> 方法的时候做两件事：</p>
<ol>
<li>为下一次调用 <code>next()</code>方法修改状态</li>
<li>为当前这次调用生成返回结果</li>
</ol>
<p>迭代器使用的是惰性计算，等到有需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 这门语言中，生成器算得上最有用的特性之一了，也算是使用最不广泛的特性之一。原因嘛，就像我开头所说的，其它主流语言没有这个概念。</p>
<p>生成器是一种特殊的迭代器，不过这种迭代器更加优雅。它不再需要上面的类一样需要写 <code>__iter__()</code>、<code>__next__()</code> 方法，只需要一个 <code>yield</code> 语句，<code>yield</code> 语句一次返回一个结果，在返回结果之后，挂起函数，以便下次从离开的地方继续执行。下面用生成器来实现斐波那契数列：</p>
<pre><code class="python">def Fib():
    prev, curr = 0, 1
    while True:
        yield curr
        prev, curr = curr, curr + prev
&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f
&lt;generator object Fib at 0x7f307048e570&gt;
&gt;&gt;&gt; &gt;&gt;&gt; for x in range(5):
...     next(f)
... 
1
1
2
3
5
</code></pre>
<p>当执行 <code>f = Fib()</code> 的时候返回的是一个生成器的对象，此时函数体的代码并没有执行，只有调用 <code>next()</code> 的时候才会真正执行代码。</p>
<p>除了给函数加上 <code>yield</code>语句之外，还有一种方法创建生成器，只要把一个列表生成式的 <code>[]</code> 改成 <code>()</code>，就创建了一个生成器：</p>
<pre><code class="python">&gt;&gt;&gt; L = [x for x in range(5)]
&gt;&gt;&gt; L
[0, 1, 2, 3, 4]
&gt;&gt;&gt; G = (x for x in range(5))
&gt;&gt;&gt; G
&lt;generator object &lt;genexpr&gt; at 0x7f307048e5c8&gt;
</code></pre>
<p>生成器在 Python 中是非常强大的，可以更少的使用中间变量，也可以更少的占用内存空间，而且可以缩减代码量来维持相同的功能：</p>
<pre><code class="python">def something():
    result = []
    for x in ... :
        result.append(x)
    return result
</code></pre>
<p>类似的都可以用生成器来替换：</p>
<pre><code class="python">def gen_something():
    for x in ... :
        yield x
</code></pre>
<p><strong>注意事项：生成器只能遍历一次</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最初接触 Python 是在 17 年 2 月份，现在半年过去了，对迭代器和生成器的概念却及其有限，其实也是因为其它主流语言如：C、Java 中没有生成器的概念，所以当时学了就忘了。现在正准备好好复习一下迭代器和生成器。&lt;/p&gt;
&lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;p&gt;容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代（即可以通过 &lt;code&gt;for&lt;/code&gt; 循环去遍历）获取，可以用 &lt;code&gt;in&lt;/code&gt;，&lt;code&gt;not in&lt;/code&gt; 关键字判断元素是否包含在容器中。&lt;/p&gt;
&lt;p&gt;在 Python 中，常见的容器对象有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list, deque&lt;/li&gt;
&lt;li&gt;set, frozensets&lt;/li&gt;
&lt;li&gt;dict, defaultdict, OrderedDict, Counter&lt;/li&gt;
&lt;li&gt;tuple, namedtuple&lt;/li&gt;
&lt;li&gt;str&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
  </entry>
  
</feed>
